<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<title>4.并发编程-协程篇</title>
<script src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" href="../../../style/css/jupyter.all.min.css">
<script src="../../../style/js/mynav.min.js" async></script>
</head>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.&#21327;&#31243;&#31687;">3.&#21327;&#31243;&#31687;<a class="anchor-link" href="#3.&#21327;&#31243;&#31687;">&#182;</a></h1><p>在线预览：<a href="https://github.lesschina.com/python/base/concurrency/4.并发编程-协程篇.html">https://github.lesschina.com/python/base/concurrency/4.并发编程-协程篇.html</a></p>
<p>示例代码：<a href="https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine">https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine</a></p>
<p>多进程和多线程切换之间也是有资源浪费的，相比而言协程更轻量级</p>
<h2 id="3.1.&#30693;&#35782;&#22238;&#39038;">3.1.&#30693;&#35782;&#22238;&#39038;<a class="anchor-link" href="#3.1.&#30693;&#35782;&#22238;&#39038;">&#182;</a></h2><h3 id="1.&#35013;&#39280;&#22120;">1.&#35013;&#39280;&#22120;<a class="anchor-link" href="#1.&#35013;&#39280;&#22120;">&#182;</a></h3><p>往期文章：<a href="https://www.cnblogs.com/dotnetcrazy/p/9333792.html#2.Python装饰器" target="_blank">https://www.cnblogs.com/dotnetcrazy/p/9333792.html#2.Python装饰器</a></p>
<p>基础拓展篇已经讲的很透彻了，就不再雷同了，贴一个简单案例，然后扩展说说<strong><code>可迭代</code>、<code>迭代器</code>和<code>生成器</code></strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kv</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> log_info...&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@log</span>
<span class="k">def</span> <span class="nf">login_out</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;已经退出登录&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># @wraps(func) 可以使得装饰前后，方法签名一致</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;方法签名：</span><span class="si">{login_out.__name__}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">login_out</span><span class="p">()</span>
    
    <span class="c1"># @wraps能让你通过属性 __wrapped__ 直接访问被包装函数</span>
    <span class="n">login_out</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">()</span> <span class="c1"># 执行原来的函数</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
方法签名：login_out
login_out log_info...
已经退出登录
已经退出登录
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="2.&#36845;&#20195;&#22120;">2.&#36845;&#20195;&#22120;<a class="anchor-link" href="#2.&#36845;&#20195;&#22120;">&#182;</a></h3><p>往期文章：<a href="https://www.cnblogs.com/dotnetcrazy/p/9278573.html#6.Python迭代器" target="_blank">https://www.cnblogs.com/dotnetcrazy/p/9278573.html#6.Python迭代器</a></p>
<p>过于基础的就不说了，简单说下，然后举一个<code>OOP</code>的<code>Demo</code>：</p>
<ol>
<li><strong>判断是否可迭代：（能不能for遍历）</strong><ul>
<li><code>from collections.abc import Iterable</code></li>
<li><code>isinstance(xxx, Iterable)</code></li>
</ul>
</li>
<li><strong>判断是否是迭代器：（能不能<code>next(xxx)</code>遍历）</strong><ul>
<li><code>from collections.abc import Iterator</code></li>
<li><code>isinstance(xxx, Iterable)</code></li>
<li>PS：迭代器是一定可以迭代的</li>
</ul>
</li>
<li><strong>可迭代对象转迭代器：（生成器都是迭代器）</strong><ul>
<li>把<code>list、dict、str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数 eg：<strong><code>iter([])</code></strong>（节省资源）</li>
<li>PS：生成器都是<code>Iterator</code>对象，但list、dict、str虽然是<code>Iterable</code>，却不是<code>Iterator</code></li>
</ul>
</li>
</ol>
<p><strong>提醒一下：<code>from collections import Iterable, Iterator # 现在已经不推荐使用了（3.8会弃用）</code></strong></p>
<p>查看一下<code>typing.py</code>的源码就知道了:</p>
<div class="highlight"><pre><span></span><span class="c1"># 模仿collections.abc中的那些（Python3.7目前只是过渡的兼容版，没有具体实现）</span>
<span class="k">def</span> <span class="nf">_alias</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">special</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">)</span>

<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>

<span class="n">Iterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">T_co</span><span class="p">)</span>
<span class="n">Iterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T_co</span><span class="p">)</span>
</pre></div>
<p>之前说了个 <a href="https://www.cnblogs.com/dotnetcrazy/p/9278573.html#7.1.IEnumerator-%E5%92%8C-IEnumerable" target="_blank">CSharp 的 OOP Demo</a>，这次来个<code>Python</code>的，我们来一步步演变：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 导入相关模块</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="c1"># from collections import Iterable, Iterator # 现在已经不推荐使用了（3.8会弃用）</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 定义一个Class</span>
<span class="k">class</span> <span class="nc">MyArray</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 是否可迭代 False</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">MyArray</span><span class="p">(),</span><span class="n">Iterable</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>False</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 是否是迭代器 False</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">MyArray</span><span class="p">(),</span><span class="n">Iterator</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[5]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>False</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 如果Class里面含有`__iter__`方法就是可迭代的</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 重新定义测试：</span>
<span class="k">class</span> <span class="nc">MyArray</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="c1"># 是否可迭代 False</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">MyArray</span><span class="p">(),</span><span class="n">Iterable</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>True</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 是否是迭代器 False</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">MyArray</span><span class="p">(),</span><span class="n">Iterator</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>False</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>这时候依然不是迭代器</strong></p>
<p>这个可以类比C#：</p>
<ol>
<li>能不能foreach就看你遍历对象有没有实现IEnumerable，就说明你是不是一个可枚举类型（enumerator type）</li>
<li>是不是个枚举器（enumerator）就看你实现了IEnumerator接口没</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1">// 能不能foreach就看你遍历对象有没有实现IEnumerable，就说明你是不是一个可枚举类型</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IEnumerable</span>
<span class="p">{</span>
    <span class="n">IEnumerator</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 是不是个枚举器（enumerator）就看你实现了IEnumerator接口没</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IEnumerator</span>
<span class="p">{</span>
    <span class="kt">object</span> <span class="n">Current</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">();</span>

    <span class="k">void</span> <span class="nf">Reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>先看看Python对于的类吧：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/_collections_abc.py</span>
<span class="k">class</span> <span class="nc">Iterable</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__subclasshook__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Iterable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_check_methods</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

<span class="k">class</span> <span class="nc">Iterator</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return the next item from the iterator. When exhausted, raise StopIteration&#39;</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__subclasshook__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Iterator</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_check_methods</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
</pre></div>
<p>读源码的好处来了==&gt;<strong><code>抽象方法：@abstractmethod（子类必须实现）</code>，上次漏讲了吧～</strong></p>
<p>上面说<strong>迭代器肯定可以迭代</strong>，说很抽象，代码太直观了 (继承)：<strong><code>class Iterator(Iterable)</code></strong></p>
<p>现在我们来模仿并实现一个<code>Python</code>版本的<code>迭代器</code>：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 先搭个空架子</span>
<span class="k">class</span> <span class="nc">MyIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyArray</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MyIterator</span><span class="p">()</span> <span class="c1"># 返回一个迭代器</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 可迭代 True</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MyArray</span><span class="p">(),</span> <span class="n">Iterable</span><span class="p">))</span>
    <span class="c1"># 迭代器也是可迭代的 True</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MyIterator</span><span class="p">(),</span> <span class="n">Iterable</span><span class="p">))</span>
    <span class="c1"># 是迭代器 True</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MyIterator</span><span class="p">(),</span> <span class="n">Iterator</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
True
True
True
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 把迭代器简化合并</span>
<span class="k">class</span> <span class="nc">MyIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="c1"># 返回一个迭代器(现在就是它自己了)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MyIterator</span><span class="p">(),</span> <span class="n">Iterable</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MyIterator</span><span class="p">(),</span> <span class="n">Iterator</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
True
True
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 马上进入正题了，先回顾一下Fibona</span>
<span class="k">def</span> <span class="nf">fibona</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># 获取10个斐波拉契数列</span>
<span class="n">fibona</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
1
1
2
3
5
8
13
21
34
55
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 改造成迭代器</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">FibonaIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n</span> <span class="o">=</span> <span class="n">n</span>  <span class="c1"># 获取多少个</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 当前索引</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 生成下一波</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span> <span class="c1"># for循环结束条件</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">FibonaIterator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FibonaIterator</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
&lt;__main__.FibonaIterator object at 0x000001CAFFD2C748&gt;
1
1
2
3
5
8
13
21
34
55
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="3.&#29983;&#25104;&#22120;">3.&#29983;&#25104;&#22120;<a class="anchor-link" href="#3.&#29983;&#25104;&#22120;">&#182;</a></h3><p>往期文章：<a href="https://www.cnblogs.com/dotnetcrazy/p/9278573.html#5.Python生成器" target="_blank">https://www.cnblogs.com/dotnetcrazy/p/9278573.html#5.Python生成器</a></p>
<p>生成器是啥？看源码就秒懂了：(<strong>迭代器的基础上再封装</strong>)</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;从生成器返回下一个item，结束的时候抛出 StopIteration&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;将值发送到生成器。返回下一个产生的值或抛出StopIteration&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">throw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tb</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;在生成器中引发异常。返回下一个产生的值或抛出StopIteration&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">typ</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">typ</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">val</span>

    <span class="c1"># 现在知道之前close后为啥没异常了吧～</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;屏蔽异常&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">GeneratorExit</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">GeneratorExit</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;generator ignored GeneratorExit&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__subclasshook__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Generator</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_check_methods</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;send&#39;</span><span class="p">,</span> <span class="s1">&#39;throw&#39;</span><span class="p">,</span> <span class="s1">&#39;close&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
</pre></div>
<p>迭代器的基础上再封装了两个抽象方法<code>send</code>、<code>throw</code>和屏蔽异常的方法<code>close</code></p>
<p>现在用生成器的方式改写下斐波拉契数列：（列表推导式改成小括号是最简单的一种生成器）</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span> <span class="n">time</span>

<span class="c1"># 代码瞬间就简洁了</span>
<span class="k">def</span> <span class="nf">fibona</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">yield</span> <span class="n">a</span> <span class="c1"># 加个yiel就变成生成器了</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fibona</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fibona</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Wall time: 0 ns
&lt;generator object fibona at 0x000001CAFFD1AC00&gt;
1
1
2
3
5
8
13
21
34
55
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>注意下这几点：</p>
<ol>
<li><a herf="https://www.cnblogs.com/dotnetcrazy/p/9278573.html#5.3.扩展之～send(msg)方法：" target="_blank">generator刚启动的时候，要么 next()，要么 send(None)，不然会引发：</a><ul>
<li><code>TypeError: can't send non-None value to a just-started generator</code></li>
</ul>
</li>
<li><a herf="https://www.cnblogs.com/dotnetcrazy/p/9278573.html#5.4.扩展之～return和break的说明" target="_blank">在一个generator函数中，遇到return或者break则直接抛出StopIteration终止迭代</a><ul>
<li>如果没有则默认执行至函数完毕</li>
</ul>
</li>
<li>如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_send</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;i==2&quot;</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">test_send</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">break</span>
</pre></div>
<p>输出：</p>

<pre><code>0
1
i==2</code></pre>
<p>其他的也没什么好说的了，读完源码再看看之前讲的内容<code>别有一番滋味在心头</code>哦～</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="3.2.&#27010;&#24565;&#31687;">3.2.&#27010;&#24565;&#31687;<a class="anchor-link" href="#3.2.&#27010;&#24565;&#31687;">&#182;</a></h2><p>上集回顾：<a href="https://mp.weixin.qq.com/s/jWRBHi_ZNDBxOXElgAk86w" target="_blank">网络：静态服务器+压测</a></p>
<h3 id="1.&#21516;&#27493;&#19982;&#24322;&#27493;">1.&#21516;&#27493;&#19982;&#24322;&#27493;<a class="anchor-link" href="#1.&#21516;&#27493;&#19982;&#24322;&#27493;">&#182;</a></h3><blockquote><p>同步是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成。</p>
<p>异步是指不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作。然后继续执行下面代码逻辑，只要自己完成了整个任务就算完成了（异步一般使用状态、通知和回调）</p>
</blockquote>
<p>PS：<strong>项目里面一般是这样的</strong>：（个人经验）</p>
<ol>
<li>同步架构：一般都是和钱相关的需求，需要实时返回的业务</li>
<li>异步架构：更多是对写要求比较高时的场景（同步变异步）<ul>
<li>读一般都是实时返回，代码一般都是<code>await xxx()</code></li>
</ul>
</li>
<li>想象个情景就清楚了：<ul>
<li>异步：现在用户写了篇文章，可以异步操作，就算没真正写到数据库也可以返回：发表成功（大不了失败提示一下）</li>
<li>同步：用户获取订单信息，你如果异步就会这样了：提示下获取成功，然后一片空白...用户不卸载就怪了...</li>
</ul>
</li>
</ol>
<h3 id="2.&#38459;&#22622;&#19982;&#38750;&#38459;&#22622;">2.&#38459;&#22622;&#19982;&#38750;&#38459;&#22622;<a class="anchor-link" href="#2.&#38459;&#22622;&#19982;&#38750;&#38459;&#22622;">&#182;</a></h3><blockquote><p>阻塞是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务（大部分代码都是这样的）</p>
<p>非阻塞是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（继续执行下面代码，或者重试机制走起）</p>
</blockquote>
<p>PS：<strong>项目里面重试机制为啥一般都是3次？</strong></p>
<ol>
<li>第一次重试，两台PC挂了也是有可能的</li>
<li>第二次重试，负载均衡分配的三台机器同时挂的可能性不是很大，这时候就有可能是网络有点拥堵了</li>
<li>最后一次重试，再失败就没意义了，日记写起来，再重试网络负担就加大了，得不偿失了</li>
</ol>
<h3 id="3.&#20116;&#31181;IO&#27169;&#22411;">3.&#20116;&#31181;IO&#27169;&#22411;<a class="anchor-link" href="#3.&#20116;&#31181;IO&#27169;&#22411;">&#182;</a></h3><p>对于一次IO访问，数据会先被拷贝到内核的缓冲区中，然后才会从内核的缓冲区拷贝到应用程序的地址空间。需要经历两个阶段：</p>
<ol>
<li>准备数据</li>
<li>将数据从内核缓冲区拷贝到进程地址空间</li>
</ol>
<p>由于存在这两个阶段，Linux产生了下面五种IO模型（<code>以socket为例</code>）</p>
<ol>
<li>阻塞式IO：<ul>
<li>当用户进程调用了<code>recvfrom</code>等阻塞方法时，内核进入IO的第1个阶段：准备数据（内核需要等待足够的数据再拷贝）这个过程需要等待，用户进程会被阻塞，等内核将数据准备好，然后拷贝到用户地址空间，内核返回结果，用户进程才从阻塞态进入就绪态</li>
<li>Linux中默认情况下所有的socket都是阻塞的</li>
</ul>
</li>
<li>非阻塞式IO：<ul>
<li>当用户进程发出read操作时，如果<code>kernel</code>中的数据还没有准备好，那么它并不会<code>block</code>用户进程，而是立刻返回一个<code>error</code>。</li>
<li>用户进程判断结果是一个<code>error</code>时，它就知道数据还没有准备好，于是它可以再次发送read操作</li>
<li>一旦<code>kernel</code>中的数据准备好了，并且又再次收到了用户进程的<code>system call</code>，那么它马上就将数据拷贝到了用户内存，然后返回</li>
<li>非阻塞IO模式下用户进程需要不断地询问内核的数据准备好了没有</li>
</ul>
</li>
<li><strong>IO多路复用</strong>：<ul>
<li>通过一种机制，一个进程可以监视多个文件描述符（套接字描述符）一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作（这样就不需要每个用户进程不断的询问内核数据准备好了没）</li>
<li>常用的IO多路复用方式有<code>select</code>、<code>poll</code>和<code>epoll</code></li>
</ul>
</li>
<li>信号驱动IO：（之前我们讲进程先导篇的时候说过）<ul>
<li>内核文件描述符就绪后，通过信号通知用户进程，用户进程再通过系统调用读取数据。</li>
<li>此方式属于同步IO（实际读取数据到用户进程缓存的工作仍然是由用户进程自己负责的）</li>
</ul>
</li>
<li><strong>异步IO</strong>（<code>POSIX</code>的<code>aio_</code>系列函数）<ul>
<li>用户进程发起read操作之后，立刻就可以开始去做其它的事。内核收到一个异步<code>IO read</code>之后，会立刻返回，不会阻塞用户进程。</li>
<li>内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个<code>signal</code>告诉它read操作完成了</li>
</ul>
</li>
</ol>
<h3 id="4.Unix&#22270;&#31034;">4.Unix&#22270;&#31034;<a class="anchor-link" href="#4.Unix&#22270;&#31034;">&#182;</a></h3><p>贴一下Unix编程里面的图：</p>
<center>非阻塞IO</center><p><img src="../../../images/python/2018-12-07/2.非阻塞IO.png" alt="2.非阻塞IO.png"></p>
<center>IO复用</center><p><img src="../../../images/python/2018-12-07/3.IO复用.png" alt="3.IO复用.png"></p>
<center>信号IO</center><p><img src="../../../images/python/2018-12-07/4.信号IO.png" alt="4.信号IO.png"></p>
<center>异步AIO</center><p><img src="../../../images/python/2018-12-07/5.异步AIO.png" alt="5.异步AIO.png"></p>
<h2 id="3.3.IO&#22810;&#36335;&#22797;&#29992;">3.3.IO&#22810;&#36335;&#22797;&#29992;<a class="anchor-link" href="#3.3.IO&#22810;&#36335;&#22797;&#29992;">&#182;</a></h2><p>开始之前咱们通过非阻塞IO引入一下：（来个简单例子<code>socket.setblocking(False)</code>)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">socket_addr_list</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span> <span class="ow">in</span> <span class="n">socket_addr_list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[来自{client_addr}的消息：]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span>
                    <span class="sa">b</span><span class="s2">&quot;HTTP/1.1 200 ok</span><span class="se">\r\n</span><span class="s2">Content-Type: text/html;charset=utf-8</span><span class="se">\r\n\r\n</span><span class="s2">&lt;h1&gt;Web Server Test&lt;/h1&gt;&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 没有消息是触发异常，空消息是断开连接</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭客户端连接</span>
                <span class="n">socket_addr_list</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[客户端{client_addr}已断开连接，当前连接数：{len(socket_addr_list)}]&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 存放客户端集合</span>
    <span class="n">socket_addr_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span> <span class="k">as</span> <span class="n">tcp_server</span><span class="p">:</span>
        <span class="c1"># 防止端口绑定的设置</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>  <span class="c1"># 服务端非阻塞</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">tcp_server</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>  <span class="c1"># 客户端非阻塞</span>
                <span class="n">socket_addr_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[来自{client_addr}的连接，当前连接数：{len(socket_addr_list)}]&quot;</span><span class="p">)</span>
            <span class="c1"># 防止客户端断开后出错</span>
            <span class="k">if</span> <span class="n">socket_addr_list</span><span class="p">:</span>
                <span class="c1"># 轮询查看客户端有没有消息</span>
                <span class="n">select</span><span class="p">(</span><span class="n">socket_addr_list</span><span class="p">)</span>  <span class="c1"># 引用传参</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：
<img src="../../../images/python/2018-12-07/6.nowait.gif" alt="6.nowait.gif"></p>
<p>可以思考下：</p>
<ol>
<li>为什么Server也要设置为非阻塞？<ul>
<li>PS：一个线程里面只能有一个死循环，现在程序需要两个死循环，so ==&gt; 放一起咯</li>
</ul>
</li>
<li>断开连接怎么判断？<ul>
<li>PS：没有消息是触发异常，空消息是断开连接</li>
</ul>
</li>
<li>client_socket为什么不用dict存放？<ul>
<li>PS：dict在循环的过程中，del会引发异常</li>
</ul>
</li>
</ol>
<h3 id="1.Select">1.Select<a class="anchor-link" href="#1.Select">&#182;</a></h3><p>select和上面的有点类似，就是轮询的过程交给了操作系统：</p>
<blockquote><p>kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程</p>
</blockquote>
<p>来个和上面等同的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span> <span class="k">as</span> <span class="n">tcp_server</span><span class="p">:</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
        <span class="n">socket_info_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">socket_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">tcp_server</span><span class="p">]</span>  <span class="c1"># 监测列表</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># 劣势：select列表数量有限制</span>
            <span class="n">read_list</span><span class="p">,</span> <span class="n">write_list</span><span class="p">,</span> <span class="n">error_list</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">socket_list</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">read_list</span><span class="p">:</span>
                <span class="c1"># 服务端迎接新的连接</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">tcp_server</span><span class="p">:</span>
                    <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
                    <span class="n">socket_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">client_socket</span><span class="p">)</span>
                    <span class="n">socket_info_dict</span><span class="p">[</span><span class="n">client_socket</span><span class="p">]</span> <span class="o">=</span> <span class="n">client_address</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[{client_address}已连接，当前连接数：{len(socket_list)-1}]&quot;</span><span class="p">)</span>
                <span class="c1"># 客户端发来</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
                        <span class="n">item</span><span class="o">.</span><span class="n">send</span><span class="p">(</span>
                            <span class="sa">b</span><span class="s2">&quot;HTTP/1.1 200 ok</span><span class="se">\r\n</span><span class="s2">Content-Type: text/html;charset=utf-8</span><span class="se">\r\n\r\n</span><span class="s2">&lt;h1&gt;Web Server Test&lt;/h1&gt;&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">item</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">socket_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                        <span class="n">info</span> <span class="o">=</span> <span class="n">socket_info_dict</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[{info}已断开，当前连接数：{len(socket_list)-1}]&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p><strong>输出和上面一样</strong></p>
<p>扩展说明：</p>
<blockquote><p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述符就绪函数返回（<strong>有数据可读、可写、或者有except</strong>）或者超时（timeout指定等待时间，如果立即返回设为null即可）</p>
<p>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024（64位=&gt;2048）</p>
</blockquote>
<p><strong>然后Poll就出现了，就是把上限给去掉了，本质并没变，还是使用的<code>轮询</code></strong></p>
<h3 id="2.EPoll">2.EPoll<a class="anchor-link" href="#2.EPoll">&#182;</a></h3><blockquote><p>epoll在内核2.6中提出（Linux独有），使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，采用监听回调的机制，这样在用户空间和内核空间的copy只需一次，避免再次遍历就绪的文件描述符列表</p>
</blockquote>
<p>先来看个案例吧：（输出和上面一样）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">select</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span> <span class="k">as</span> <span class="n">tcp_server</span><span class="p">:</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>
        <span class="n">tcp_server</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>

        <span class="c1"># epoll是linux独有的</span>
        <span class="n">epoll</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">epoll</span><span class="p">()</span>
        <span class="c1"># tcp_server注册到epoll中</span>
        <span class="n">epoll</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tcp_server</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">select</span><span class="o">.</span><span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">select</span><span class="o">.</span><span class="n">EPOLLET</span><span class="p">)</span>

        <span class="c1"># key-value</span>
        <span class="n">fd_socket_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># 回调需要自己处理</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># 返回可读写的socket fd 集合</span>
            <span class="n">poll_list</span> <span class="o">=</span> <span class="n">epoll</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">poll_list</span><span class="p">:</span>
                <span class="c1"># 服务器的socket</span>
                <span class="k">if</span> <span class="n">fd</span> <span class="o">==</span> <span class="n">tcp_server</span><span class="o">.</span><span class="n">fileno</span><span class="p">():</span>
                    <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">tcp_server</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
                    <span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
                    <span class="c1"># 把客户端注册进epoll中</span>
                    <span class="n">epoll</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">select</span><span class="o">.</span><span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">select</span><span class="o">.</span><span class="n">EPOLLET</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># 客户端</span>
                    <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span>
                        <span class="n">f</span><span class="s2">&quot;[来自{client_addr}的消息，当前连接数：{len(fd_socket_dict)}]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
                        <span class="n">client_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span>
                            <span class="sa">b</span><span class="s2">&quot;HTTP/1.1 200 ok</span><span class="se">\r\n</span><span class="s2">Content-Type: text/html;charset=utf-8</span><span class="se">\r\n\r\n</span><span class="s2">&lt;h1&gt;Web Server Test&lt;/h1&gt;&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
                        <span class="k">print</span><span class="p">(</span>
                            <span class="n">f</span><span class="s2">&quot;[{client_addr}已离线，当前连接数：{len(fd_socket_dict)}]</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="c1"># 从epoll中注销</span>
                        <span class="n">epoll</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                        <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>扩展：<strong>epoll的两种工作模式</strong></p>
<blockquote><p>LT（level trigger，水平触发）模式：当epoll_wait检测到描述符就绪，将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。LT模式是默认的工作模式。
LT模式同时支持阻塞和非阻塞socket。</p>
<p>ET（edge trigger，边缘触发）模式：当epoll_wait检测到描述符就绪，将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
ET是高速工作方式，只支持非阻塞socket（ET模式减少了epoll事件被重复触发的次数，因此效率要比LT模式高）</p>
</blockquote>
<p><strong>Code提炼一下</strong>：</p>
<ol>
<li>实例化对象：<code>epoll = select.epoll()</code></li>
<li>注册对象：<code>epoll.register(tcp_server.fileno(), select.EPOLLIN | select.EPOLLET)</code></li>
<li>注销对象：<code>epoll.unregister(fd)</code></li>
</ol>
<p>PS：<code>epoll</code>不一定比<code>Select</code>性能高，一般都是分场景的：</p>
<ol>
<li>高并发下，连接活跃度不高时：epoll比Select性能高（eg：web请求，页面随时关闭）</li>
<li>并发不高，连接活跃度比较高：Select更合适（eg：小游戏）</li>
<li><strong>Select是win和linux通用的，而epoll只有linux有</strong></li>
</ol>
<p>其实IO多路复用还有一个<code>kqueue</code>，和<code>epoll</code>类似，下面的通用写法中有包含</p>
<hr>
<h3 id="3.&#36890;&#29992;&#20889;&#27861;&#65288;Selector&#65289;">3.&#36890;&#29992;&#20889;&#27861;&#65288;<code>Selector</code>&#65289;<a class="anchor-link" href="#3.&#36890;&#29992;&#20889;&#27861;&#65288;Selector&#65289;">&#182;</a></h3><p>一般来说：<strong>Linux下使用epoll，Win下使用select</strong>（IO多路复用会这个通用的即可）</p>
<p>先看看Python源代码：</p>
<div class="highlight"><pre><span></span><span class="c1"># 选择级别：epoll|kqueue|devpoll &gt; poll &gt; select</span>
<span class="k">if</span> <span class="s1">&#39;KqueueSelector&#39;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
    <span class="n">DefaultSelector</span> <span class="o">=</span> <span class="n">KqueueSelector</span>
<span class="k">elif</span> <span class="s1">&#39;EpollSelector&#39;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
    <span class="n">DefaultSelector</span> <span class="o">=</span> <span class="n">EpollSelector</span>
<span class="k">elif</span> <span class="s1">&#39;DevpollSelector&#39;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
    <span class="n">DefaultSelector</span> <span class="o">=</span> <span class="n">DevpollSelector</span>
<span class="k">elif</span> <span class="s1">&#39;PollSelector&#39;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
    <span class="n">DefaultSelector</span> <span class="o">=</span> <span class="n">PollSelector</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">DefaultSelector</span> <span class="o">=</span> <span class="n">SelectSelector</span>
</pre></div>
<p><strong>实战案例</strong>：(可读和可写可以不分开)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="c1"># Linux下使用epoll，Win下使用select</span>
<span class="n">Selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 存放客户端fd和socket键值对</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fd_socket_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
        <span class="c1"># 把Server注册到epoll</span>
        <span class="n">Selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;客户端连接时处理&quot;&quot;&quot;</span>
        <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
        <span class="c1"># 注册一个客户端读的事件（服务端去读消息）</span>
        <span class="n">Selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_back_reads</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{client_address}已连接，当前连接数：{len(self.fd_socket_dict)}&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call_back_reads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;客户端可读时处理&quot;&quot;&quot;</span>
        <span class="c1"># 一个fd只能注册一次，监测可写的时候需要把可读给注销</span>
        <span class="n">Selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[来自{client_address}的消息:]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
            <span class="c1"># 注册一个客户端写的事件（服务端去发消息）</span>
            <span class="n">Selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_WRITE</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">call_back_writes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{client_address}已断开，当前连接数：{len(self.fd_socket_dict)}&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call_back_writes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;客户端可写时处理&quot;&quot;&quot;</span>
        <span class="n">Selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">client_socket</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fd_socket_dict</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">]</span>
        <span class="n">client_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>
        <span class="n">Selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_back_reads</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="n">Selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ready</span><span class="p">:</span>
            <span class="c1"># 需要自己回调</span>
            <span class="n">call_back</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">call_back</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p><strong>Code提炼一下</strong>：</p>
<ol>
<li>实例化对象：<code>Selector = selectors.DefaultSelector()</code></li>
<li>注册对象：<ul>
<li><code>Selector.register(server.fileno(), selectors.EVENT_READ, call_back)</code></li>
<li><code>Selector.register(server.fileno(), selectors.EVENT_WRITE, call_back)</code></li>
</ul>
</li>
<li>注销对象：<code>Selector.unregister(key.fd)</code></li>
<li>注意一下：<strong>一个fd只能注册一次，监测可写的时候需要把可读给注销（反之一样）</strong></li>
</ol>
<p>业余拓展：</p>

<pre><code>select, iocp, epoll,kqueue及各种I/O复用机制
https://blog.csdn.net/shallwake/article/details/5265287

kqueue用法简介
http://www.cnblogs.com/luminocean/p/5631336.html</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="3.4.&#21327;&#31243;&#24341;&#20837;">3.4.&#21327;&#31243;&#24341;&#20837;<a class="anchor-link" href="#3.4.&#21327;&#31243;&#24341;&#20837;">&#182;</a></h2><h3 id="1.yield-from">1.yield from<a class="anchor-link" href="#1.yield-from">&#182;</a></h3><p>我们经常有这样的需求：<code>读取两个分表的数据列表，然后合并之后进行一些处理</code></p>
<p>平时可以借用<code>itertools.chain</code>来遍历：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://docs.python.org/3/library/itertools.html#itertools.chain</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 模拟分表后的两个查询结果</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小张&quot;</span><span class="p">,</span> <span class="s2">&quot;小明&quot;</span><span class="p">]</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小潘&quot;</span><span class="p">,</span> <span class="s2">&quot;小周&quot;</span><span class="p">]</span>
    <span class="c1"># dict只能遍历key（这种情况需要自己封装合并方法并处理下）</span>
    <span class="n">user3</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test1&quot;</span><span class="p">,</span> <span class="s2">&quot;name1&quot;</span><span class="p">:</span> <span class="s2">&quot;test2&quot;</span><span class="p">}</span>

    <span class="c1"># 需求：合并并遍历</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>小张
小明
小潘
小周
name
name1</code></pre>
<p>它的内部实现其实是这样的：（<code>相当于两层遍历，用yield返回</code>）</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_chain</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 模拟分表后的两个查询结果</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小张&quot;</span><span class="p">,</span> <span class="s2">&quot;小明&quot;</span><span class="p">]</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小潘&quot;</span><span class="p">,</span> <span class="s2">&quot;小周&quot;</span><span class="p">]</span>
    <span class="c1"># dict只能遍历key（这种情况需要自己封装合并方法并处理下）</span>
    <span class="n">user3</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test1&quot;</span><span class="p">,</span> <span class="s2">&quot;name1&quot;</span><span class="p">:</span> <span class="s2">&quot;test2&quot;</span><span class="p">}</span>

    <span class="c1"># 需求：合并并遍历</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_chain</span><span class="p">(</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>然后<code>Python3.3</code>之后语法再一步简化（<strong><code>yield from iterable对象</code></strong>）</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_chain</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">items</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 模拟分表后的两个查询结果</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小张&quot;</span><span class="p">,</span> <span class="s2">&quot;小明&quot;</span><span class="p">]</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小潘&quot;</span><span class="p">,</span> <span class="s2">&quot;小周&quot;</span><span class="p">]</span>

    <span class="c1"># 需求：合并并遍历</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_chain</span><span class="p">(</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>小张
小明
小潘
小周
test1
test2</code></pre>
<h4 id="&#25193;&#23637;&#65288;&#21487;&#24573;&#30053;&#65289;">&#25193;&#23637;&#65288;&#21487;&#24573;&#30053;&#65289;<a class="anchor-link" href="#&#25193;&#23637;&#65288;&#21487;&#24573;&#30053;&#65289;">&#182;</a></h4><p>其实知道了内部实现，很容易就写上一段应对的处理：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_chain</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">my_iterable</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="c1"># 如果是字典类型就返回value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_iterable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">my_iterable</span> <span class="o">=</span> <span class="n">my_iterable</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_iterable</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 模拟分表后的两个查询结果</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小张&quot;</span><span class="p">,</span> <span class="s2">&quot;小明&quot;</span><span class="p">]</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;小潘&quot;</span><span class="p">,</span> <span class="s2">&quot;小周&quot;</span><span class="p">]</span>
    <span class="c1"># dict只能遍历key（这种情况需要自己封装合并方法并处理下）</span>
    <span class="n">user3</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test1&quot;</span><span class="p">,</span> <span class="s2">&quot;name1&quot;</span><span class="p">:</span> <span class="s2">&quot;test2&quot;</span><span class="p">}</span>
    <span class="c1"># 需求：合并并遍历</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_chain</span><span class="p">(</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>小张
小明
小潘
小周
test1
test2</code></pre>
<h4 id="&#25193;&#23637;&#30340;&#27491;&#30830;&#22788;&#29702;">&#25193;&#23637;&#30340;&#27491;&#30830;&#22788;&#29702;<a class="anchor-link" href="#&#25193;&#23637;&#30340;&#27491;&#30830;&#22788;&#29702;">&#182;</a></h4><p>PS：一般不会这么干的，一般都是<code>[{},{}]</code>遍历并处理：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 模拟分表后的两个查询结果</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;小张&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;小明&quot;</span><span class="p">}]</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;小潘&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;小周&quot;</span><span class="p">}]</span>
    <span class="n">user3</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test1&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test2&quot;</span><span class="p">}]</span>
    <span class="c1"># 需求：合并并遍历</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">):</span>
        <span class="c1"># 一般都是直接在这里进行处理</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<h3 id="1.yield&#29256;&#21327;&#31243;">1.yield&#29256;&#21327;&#31243;<a class="anchor-link" href="#1.yield&#29256;&#21327;&#31243;">&#182;</a></h3><p>协程的目的其实很简单：<strong>像写同步代码那样实现异步编程</strong></p>
<p>先看个需求：<strong>生成绘图的数据（<code>max,min,avg</code>）</strong></p>
<p>比如说原来数据是这样的：</p>
<div class="highlight"><pre><span></span><span class="n">products</span> <span class="o">=</span> <span class="p">[{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
    <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
    <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">]</span>
<span class="p">}]</span>
</pre></div>
<p>处理之后：</p>
<div class="highlight"><pre><span></span><span class="n">new_products</span> <span class="o">=</span> <span class="p">[{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
    <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">],</span>
    <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="mi">120</span><span class="p">,</span>
    <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="mi">76</span><span class="p">,</span>
    <span class="s2">&quot;avg&quot;</span><span class="p">:</span> <span class="mf">96.0</span>
<span class="p">},</span>
<span class="p">{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
    <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">],</span>
    <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="mi">89</span><span class="p">,</span>
    <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="s2">&quot;avg&quot;</span><span class="p">:</span> <span class="mf">61.25</span>
<span class="p">}]</span>
</pre></div>
<p>处理过的数据一般用来画图，实际效果类似于：
<img src="../../../images/python/2018-12-07/1.需求.png" alt="1.需求.png"></p>
<p>如果不借助协程，我们一般这么处理：（数据库获取过程省略）</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 生成新的dict数据</span>
<span class="k">def</span> <span class="nf">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="n">prices</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">item</span>

<span class="k">def</span> <span class="nf">get_new_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">newdata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">new_item</span> <span class="o">=</span> <span class="n">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># print(new_item) # 处理后的新dict</span>
        <span class="n">newdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newdata</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 需求：生成绘图的数据（max,min,avg）</span>
    <span class="n">products</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">]</span>
    <span class="p">}]</span>

    <span class="n">new_products</span> <span class="o">=</span> <span class="n">get_new_data</span><span class="p">(</span><span class="n">products</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">new_products</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>[{&#39;id&#39;: 2344, &#39;title&#39;: &#39;御泥坊补水面膜&#39;, &#39;price&#39;: [89, 76, 120, 99], &#39;avg&#39;: 96.0, &#39;max&#39;: 120, &#39;min&#39;: 76}, {&#39;id&#39;: 2345, &#39;title&#39;: &#39;御泥坊火山泥面膜&#39;, &#39;price&#39;: [30, 56, 70, 89], &#39;avg&#39;: 61.25, &#39;max&#39;: 89, &#39;min&#39;: 30}]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>改成yield版的协程也很方便，基本上代码没有变，也不用像IO多路复用那样来回的回调</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 生成新的dict数据</span>
<span class="k">def</span> <span class="nf">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="n">prices</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">item</span>

<span class="k">def</span> <span class="nf">get_new_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 需求：生成绘图的数据（max,min,avg）</span>
    <span class="n">products</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">]</span>
    <span class="p">}]</span>
    <span class="n">new_products</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># 如果需要返回值就捕获StopIteration异常</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">get_new_data</span><span class="p">(</span><span class="n">products</span><span class="p">):</span>
        <span class="n">new_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">new_products</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>[{&#39;id&#39;: 2344, &#39;title&#39;: &#39;御泥坊补水面膜&#39;, &#39;price&#39;: [89, 76, 120, 99], &#39;avg&#39;: 96.0, &#39;max&#39;: 120, &#39;min&#39;: 76}, {&#39;id&#39;: 2345, &#39;title&#39;: &#39;御泥坊火山泥面膜&#39;, &#39;price&#39;: [30, 56, 70, 89], &#39;avg&#39;: 61.25, &#39;max&#39;: 89, &#39;min&#39;: 30}]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>简单解析一下：（用<code>yield from</code>的目的就是为了引出等会说的<code>async/await</code>）</p>
<p><strong><code>yield from</code>（委托生成器<code>get_new_data</code>）的好处就是让调用方（<code>main</code>）和<code>yield</code>子生成器(<code>get_new_item</code>)直接建立一个双向通道</strong></p>
<p>你也可以把<code>yield from</code>当作一个中介(<strong>如果不理解就把<code>yield from</code>想象成<code>await</code>就容易理解了</strong>)，本质就是下面代码：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 生成新的数据</span>
<span class="k">def</span> <span class="nf">get_new_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">prices</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span>
        <span class="n">item</span><span class="p">[</span><span class="s2">&quot;avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="n">item</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="n">item</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">item</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 需求：生成绘图的数据（max,min,avg）</span>
    <span class="n">products</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">]</span>
    <span class="p">}]</span>
    <span class="n">new_products</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">get_new_data</span><span class="p">(</span><span class="n">products</span><span class="p">):</span>
        <span class="n">new_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">new_products</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>[{&#39;id&#39;: 2344, &#39;title&#39;: &#39;御泥坊补水面膜&#39;, &#39;price&#39;: [89, 76, 120, 99], &#39;avg&#39;: 96.0, &#39;max&#39;: 120, &#39;min&#39;: 76}, {&#39;id&#39;: 2345, &#39;title&#39;: &#39;御泥坊火山泥面膜&#39;, &#39;price&#39;: [30, 56, 70, 89], &#39;avg&#39;: 61.25, &#39;max&#39;: 89, &#39;min&#39;: 30}]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="PEP-380&#65288;&#21547;&#20998;&#26512;&#65289;">PEP 380&#65288;&#21547;&#20998;&#26512;&#65289;<a class="anchor-link" href="#PEP-380&#65288;&#21547;&#20998;&#26512;&#65289;">&#182;</a></h4><p><code>yield from</code>内部其实在<code>yield</code>基础上做了很多事情（比如一些异常的处理），具体可以看看 <strong><a href="https://www.python.org/dev/peps/pep-0380/" target="_blank">PEP 380</a></strong></p>
<p>先提炼一个<code>简版</code>的：</p>
<div class="highlight"><pre><span></span><span class="c1"># 正常调用</span>
<span class="n">RESULT</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">EXPR</span>

<span class="c1"># _i：子生成器（也是个迭代器）</span>
<span class="c1"># _y：子生成器生产的值</span>
<span class="c1"># _r：yield from 表达式最终结果</span>
<span class="c1"># _s：调用方通过send发送的值</span>
<span class="c1"># _e：异常对象</span>

<span class="c1"># 内部原理</span>
<span class="n">_i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">EXPR</span><span class="p">)</span> <span class="c1"># EXPR是一个可迭代对象，_i是子生成器</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># 第一次不能send值，只能next() or send(None)，并把产生的值放到_y中</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
    <span class="c1"># 如果子生成器直接就return了，那就会抛出异常，通过value可以拿到子生成器的返回值</span>
    <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># 尝试进行循环（调用方和子生成器交互过程），yield from这个生成器会阻塞（委托生成器）</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># 这时候子生成器已经和调用方建立了双向通道，在等待调用方send(value)，把这个值保存在_s中</span>
        <span class="n">_s</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">_y</span> <span class="c1"># 这边还会进行一系列异常处理，我先删掉，等会看</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 如果send(None)，那么继续next遍历</span>
            <span class="k">if</span> <span class="n">_s</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span> <span class="c1"># 把子生成器结果放到 _y 中</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="c1"># 如果调用方send一个值，就转发到子生成器</span>
        <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 如果子生成器遍历完了，就把返回值给_r</span>
            <span class="k">break</span>
<span class="n">RESULT</span> <span class="o">=</span> <span class="n">_r</span> <span class="c1"># 最终的返回值（yield from 最终的返回值）</span>
</pre></div>
<p>现在再来看<code>完整版</code>压力就没有那么大了：</p>
<div class="highlight"><pre><span></span><span class="c1"># 正常调用</span>
<span class="n">RESULT</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">EXPR</span>

<span class="c1"># _i：子生成器（也是个迭代器）</span>
<span class="c1"># _y：子生成器生产的值</span>
<span class="c1"># _r：yield from 表达式最终结果</span>
<span class="c1"># _s：调用方通过send发送的值</span>
<span class="c1"># _e：异常对象</span>

<span class="c1"># 内部原理</span>
<span class="n">_i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">EXPR</span><span class="p">)</span> <span class="c1"># EXPR是一个可迭代对象，_i是子生成器</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># 第一次不能send值，只能next() or send(None)，并把产生的值放到_y中</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
    <span class="c1"># 如果子生成器直接就return了，那就会抛出异常，通过value可以拿到子生成器的返回值</span>
    <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># 尝试进行循环（调用方和子生成器交互过程），yield from这个生成器会阻塞（委托生成器）</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 这时候子生成器已经和调用方建立了双向通道，在等待调用方send(value)，把这个值保存在_s中</span>
            <span class="n">_s</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">_y</span>

        <span class="c1"># 【现在补全】有这么几种情况需要处理</span>
        <span class="c1"># 1.子生成器可能只是一个迭代器，并不能作为协程的生成器（不支持throw和close）</span>
        <span class="c1"># 2.子生成器虽然支持了throw和close，但在子生成器内部两种方法都会抛出异常</span>
        <span class="c1"># 3.调用法调用了gen.throw()，想让子生成器自己抛异常</span>
        <span class="c1"># 这时候就要处理 gen.close() 和 gen.throw()的情况</span>

        <span class="c1"># 生成器close()异常的处理</span>
        <span class="k">except</span> <span class="ne">GeneratorExit</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">close</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1"># 屏蔽close的异常</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_m</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">_e</span> <span class="c1"># 上抛异常</span>
        <span class="c1"># 生成器throw()异常的处理</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">throw</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">_e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="n">_m</span><span class="p">(</span><span class="o">*</span><span class="n">_x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
                    <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># 如果send(None)，那么继续next遍历</span>
                <span class="k">if</span> <span class="n">_s</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span> <span class="c1"># 把子生成器结果放到 _y 中</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_y</span> <span class="o">=</span> <span class="n">_i</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="c1"># 如果调用方send一个值，就转发到子生成器</span>
            <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
                <span class="n">_r</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 如果子生成器遍历完了，就把返回值给_r</span>
                <span class="k">break</span>
<span class="n">RESULT</span> <span class="o">=</span> <span class="n">_r</span> <span class="c1"># 最终的返回值（yield from 最终的返回值）</span>
</pre></div>
<h3 id="2.async/await">2.async/await<a class="anchor-link" href="#2.async/await">&#182;</a></h3><p>把上面的原生代码用<code>async和await</code>改装一下：(<strong>协程的目的就是像写同步代码一样写异步，这个才算是真做到了</strong>)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 生成新的dict数据</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="n">prices</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">item</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">item</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_new_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">newdata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">new_item</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_new_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># print(new_item) # 处理后的新dict</span>
        <span class="n">newdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newdata</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 需求：生成绘图的数据（max,min,avg）</span>
    <span class="n">products</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2344</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊补水面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">89</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;御泥坊火山泥面膜&quot;</span><span class="p">,</span>
        <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">89</span><span class="p">]</span>
    <span class="p">}]</span>

    <span class="c1"># python 3.7</span>
    <span class="n">new_products</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">get_new_data</span><span class="p">(</span><span class="n">products</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">new_products</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（是不是很原生代码没啥区别？）</p>

<pre><code>[{'id': 2344, 'title': '御泥坊补水面膜', 'price': [89, 76, 120, 99], 'avg': 96.0, 'max': 120, 'min': 76}, 
{'id': 2345, 'title': '御泥坊火山泥面膜', 'price': [30, 56, 70, 89], 'avg': 61.25, 'max': 89, 'min': 30}]</code></pre>
<p>下级预估：<strong>asyncio</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="3.5.asyncio">3.5.asyncio<a class="anchor-link" href="#3.5.asyncio">&#182;</a></h2><p>官方文档：<a href="https://docs.python.org/3/library/asyncio.html" target="_blank">https://docs.python.org/3/library/asyncio.html</a></p>
<p>开发中常见错误：<a href="https://docs.python.org/3/library/asyncio-dev.html" target="_blank">https://docs.python.org/3/library/asyncio-dev.html</a></p>
<p>代码示例：<a href="https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine">https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine</a></p>
<p><strong>PS：<code>asyncio</code>是<code>Python</code>用于解决<code>异步IO</code>编程的<code>一整套</code>解决方案</strong></p>
<h3 id="3.5.1.&#19978;&#33410;&#22238;&#39038;">3.5.1.&#19978;&#33410;&#22238;&#39038;<a class="anchor-link" href="#3.5.1.&#19978;&#33410;&#22238;&#39038;">&#182;</a></h3><p>上次说了下<a href="https://mp.weixin.qq.com/s/5d701WQG1L8mDOO-bnKXdQ" target="_blank">协程演变过程</a>，这次继续，先接着上次的说：</p>
<p>像<code>JS</code>是可以生成器和<code>async</code>和<code>await</code>混用的，那<code>Python</code>呢？（NetCore不可以混用）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>

<span class="c1"># 和生成器完全分开了，不过可以理解为yield from</span>
<span class="nd">@types.coroutine</span>
<span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">value</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="c1"># 一系列逻辑处理</span>
    <span class="k">return</span> <span class="n">await</span> <span class="n">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">get_name</span><span class="p">(</span><span class="s2">&quot;小明&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
<span class="c1"># 直接混用会报错：TypeError: object generator can&#39;t be used in &#39;await&#39; expression</span>
</pre></div>
<p>我们的<code>async</code>和<code>await</code>虽然和<code>yield from</code>不是一个概念，但是可以理解为<code>yield from</code>上面这段代码你可以理解为：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>

<span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">value</span>

<span class="c1"># 这个async和await替换成yield from</span>
<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="c1"># 一系列逻辑处理</span>
    <span class="k">yield from</span> <span class="n">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">get_name</span><span class="p">(</span><span class="s2">&quot;小明&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
</pre></div>
<p>PS：<strong>Python默认和NetCore一样，不能直接混用，如果你一定要混用，那么得处理下</strong>（<code>使用@asyncio.coroutine</code>也行）</p>
<h3 id="3.5.2.asyncio&#24341;&#20837;">3.5.2.asyncio&#24341;&#20837;<a class="anchor-link" href="#3.5.2.asyncio&#24341;&#20837;">&#182;</a></h3><p>在今天之前，协程我们是这么实现的：<code>事件循环(loop)</code>+<code>回调(驱动生成器)</code>+<code>IO多路复用(epoll)</code></p>
<p>现在可以通过官方提供的<code>asyncio</code>（<strong>可以理解为协程池</strong>）来实现了（第三方还有一个<code>uvloop</code>【基于C写的<code>libuv</code>库（<code>nodejs</code>也是基于这个库）】）</p>
<p>PS：<code>uvloop</code>的使用非常简单，只要在获取事件循环前将<code>asyncio</code>的事件循环策略设置为<code>uvloop</code>的:<strong><code>asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</code></strong></p>
<h4 id="1.&#31616;&#21333;&#26696;&#20363;">1.&#31616;&#21333;&#26696;&#20363;<a class="anchor-link" href="#1.&#31616;&#21333;&#26696;&#20363;">&#182;</a></h4><p>先看个简单的协程案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="c1"># 不能再使用以前阻塞的暂停了</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;ok&quot;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># # &gt;=python3.4</span>
    <span class="c1"># # 返回asyncio的事件循环</span>
    <span class="c1"># loop = asyncio.get_event_loop()</span>
    <span class="c1"># # 运行事件循环，直到指定的future运行完毕，返回结果</span>
    <span class="c1"># result = loop.run_until_complete(test())</span>
    <span class="c1"># print(result)</span>

    <span class="c1"># python3.7</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">test</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>start...
end...
ok
2.001772403717041</code></pre>
<p>简单说下，<code>asyncio.run</code>是python3.7才简化出来的语法（类比NetCore的<code>Task.Run</code>）看看源码就知道了：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/asyncio/runners.py</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c1"># 以前是直接使用&quot;asyncio.get_event_loop()&quot;（开发人员一般都习惯这个了）</span>
    <span class="c1"># 3.7开始推荐使用&quot;asyncio.get_running_loop()&quot;来获取正在运行的loop（获取不到就抛异常）</span>
    <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">_get_running_loop</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;无法从正在运行的事件循环中调用asyncio.run()&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coroutines</span><span class="o">.</span><span class="n">iscoroutine</span><span class="p">(</span><span class="n">main</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{!r}应该是一个协程&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">main</span><span class="p">))</span>

    <span class="n">loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span> <span class="c1"># 创建一个新的事件循环</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">events</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>  <span class="c1"># 设置事件循环</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span>  <span class="c1"># 是否调试运行（默认否）</span>
        <span class="k">return</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>  <span class="c1"># 等待运行</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_cancel_all_tasks</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>  <span class="c1"># 取消其他任务</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">events</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>新版本其实就是使用了一个新的<code>loop</code>去启动<code>run_until_complete</code></p>
<p>PS：<code>uvloop</code>也可以这样去使用：获取loop<code>loop = uvloop.new_event_loop()</code>再替换原生的loop<code>asyncio.set_event_loop(loop)</code></p>
<h3 id="3.5.3.&#25209;&#37327;&#20219;&#21153;">3.5.3.&#25209;&#37327;&#20219;&#21153;<a class="anchor-link" href="#3.5.3.&#25209;&#37327;&#20219;&#21153;">&#182;</a></h3><h4 id="1.&#26087;&#29256;&#26412;&#23454;&#29616;">1.&#26087;&#29256;&#26412;&#23454;&#29616;<a class="anchor-link" href="#1.&#26087;&#29256;&#26412;&#23454;&#29616;">&#182;</a></h4><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="c1"># 不能再使用以前阻塞的暂停了</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># # &gt;=python3.4</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="c1"># tasks = [asyncio.ensure_future(test(i)) for i in range(10)]</span>
    <span class="c1"># 注意：是loop的方法，而不是asyncio的，不然就会引发RuntimeError：no running event loop</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(tasks替换成这个也一样：<code>tasks = [asyncio.ensure_future(test(i)) for i in range(10)]</code>)</p>

<pre><code>start...
start...
start...
start...
start...
start...
start...
start...
start...
start...
end...
end...
end...
end...
end...
end...
end...
end...
end...
end...
0
1
2
3
4
5
6
7
8
9
2.028331995010376</code></pre>
<p>然后我们再看看这个<code>asyncio.wait</code>是个啥：（回顾：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#wait()说明">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#wait()说明</a>）</p>

<pre><code># return_when 这个参数和之前一样
FIRST_COMPLETED = concurrent.futures.FIRST_COMPLETED
FIRST_EXCEPTION = concurrent.futures.FIRST_EXCEPTION
ALL_COMPLETED = concurrent.futures.ALL_COMPLETED

# 官方准备在未来版本废弃它的loop参数
# 和concurrent.futures里面的wait不一样，这边是个协程
async def wait(fs, *, loop=None, timeout=None, return_when=ALL_COMPLETED):</code></pre>
<p><strong>平时使用可以用高级API<code>asyncio.gather(*tasks)</code>来替换<code>asyncio.wait(tasks)</code></strong></p>
<h4 id="1.&#26087;&#29256;&#21478;&#29992;">1.&#26087;&#29256;&#21478;&#29992;<a class="anchor-link" href="#1.&#26087;&#29256;&#21478;&#29992;">&#182;</a></h4><p>PS：官方推荐使用<code>create_task的方式</code>来创建一个任务</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="c1"># 不能再使用以前阻塞的暂停了</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="c1"># await task 可以得到返回值（得到结果或者异常）</span>
    <span class="c1"># for task in asyncio.as_completed(tasks):</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         print(await task)</span>
    <span class="c1">#     except Exception as ex:</span>
    <span class="c1">#         print(ex)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">await</span> <span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">tasks</span><span class="p">)]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># old推荐使用</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">result_list</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(PS：用<code>asyncio.gather(*tasks)</code>直接替换<code>asyncio.wait(tasks)</code>也行)</p>

<pre><code>start...
start...
start...
start...
start...
start...
start...
start...
start...
start...
end...
end...
end...
end...
end...
end...
end...
end...
end...
end...
[1, 6, 4, 5, 0, 7, 8, 3, 2, 9]
2.0242035388946533</code></pre>
<p><strong>其实理解起来很简单，而且和<code>NetCore</code>以及<code>NodeJS</code>它们统一了，只要是<code>await xxx</code>就返回一个（<code>结果</code>|<code>异常</code>），<code>不await</code>就是一个<code>task对象</code></strong></p>
<h4 id="2.&#26032;&#29256;&#26412;&#23454;&#29616;">2.&#26032;&#29256;&#26412;&#23454;&#29616;<a class="anchor-link" href="#2.&#26032;&#29256;&#26412;&#23454;&#29616;">&#182;</a></h4><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="c1"># 给`协程/futures`返回一个future聚合结果</span>
    <span class="k">return</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span> <span class="c1"># 记得加*来解包</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># python3.7</span>
    <span class="n">result_list</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span>

    <span class="c1"># 2.0259485244750977</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(语法简化太多了，用起来特别简单)</p>

<pre><code>start...
start...
start...
start...
start...
start...
start...
start...
start...
start...
end...
end...
end...
end...
end...
end...
end...
end...
end...
end...
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
2.00840163230896</code></pre>
<p>关于参数需要加<code>*</code>解包的说明 ==&gt; 看看函数定义就秒懂了：</p>
<div class="highlight"><pre><span></span><span class="c1"># 给 协程/futures 返回一个future聚合结果</span>
<span class="k">def</span> <span class="nf">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coros_or_futures</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># 把协程或者awaitable对象包裹成task</span>
<span class="k">def</span> <span class="nf">ensure_future</span><span class="p">(</span><span class="n">coro_or_future</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># 传入一个协程对象，返回一个task对象</span>
<span class="k">class</span> <span class="nc">BaseEventLoop</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">create_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
<h3 id="&#20851;&#20110;&#39640;&#32423;&#21644;&#20302;&#32423;API&#30340;&#35828;&#26126;">&#20851;&#20110;&#39640;&#32423;&#21644;&#20302;&#32423;API&#30340;&#35828;&#26126;<a class="anchor-link" href="#&#20851;&#20110;&#39640;&#32423;&#21644;&#20302;&#32423;API&#30340;&#35828;&#26126;">&#182;</a></h3><p><strong>asyncio的高级（<code>high-level</code>）API一般用于这几个方面</strong>：（开发基本够用了）</p>
<ol>
<li>并行运行Python协同程序并完全控制它们的执行</li>
<li><strong>网络通信（<code>IO</code>）和进程间通信（<code>IPC</code>）</strong></li>
<li><strong>子进程</strong>（<code>subprocesses</code>）相关</li>
<li>通过<strong>队列</strong>（<code>Queue</code>）分配任务（<code>Tasks</code>）</li>
<li><strong>同步</strong>（<code>synchronize</code>）并发代码</li>
</ol>
<p><strong>低级（<code>low-level</code>）API一般这么用</strong>：（事件循环和回调会用下，其他基本不用）</p>
<ol>
<li>创建和管理<strong>事件循环</strong>，为网络、子进程、信号处理（<code>Signal</code>）等提供异步（<code>asynchronous</code>）API</li>
<li>为传输使用高效协议</li>
<li>使用<code>async/await</code>语法桥接基于<strong>回调</strong>的库和代码</li>
</ol>
<h3 id="3.5.4.&#22238;&#35843;&#20989;&#25968;">3.5.4.&#22238;&#35843;&#20989;&#25968;<a class="anchor-link" href="#3.5.4.&#22238;&#35843;&#20989;&#25968;">&#182;</a></h3><p>回调一般不利于代码维护，现在基本上是尽量不用了（异步代码用起来都和同步没多大差别了，回调也就没那么大用处了）</p>
<h4 id="1.&#22238;&#35843;&#20989;&#25968;&#33719;&#21462;&#36820;&#22238;&#20540;">1.&#22238;&#35843;&#20989;&#25968;&#33719;&#21462;&#36820;&#22238;&#20540;<a class="anchor-link" href="#1.&#22238;&#35843;&#20989;&#25968;&#33719;&#21462;&#36820;&#22238;&#20540;">&#182;</a></h4><p>上面说的获取返回值，其实也可以通过回调函数来获取：</p>
<div class="highlight"><pre><span></span><span class="c1"># 低级API示例</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get {url} ing&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="k">def</span> <span class="nf">call_back</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span>
    <span class="p">]</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># 任务集合</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
        <span class="c1"># task = asyncio.ensure_future(get_html(url))</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
        <span class="c1"># 设置回调函数</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">call_back</span><span class="p">)</span>
        <span class="c1"># 添加到任务集合中</span>
        <span class="n">tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="c1"># 批量执行</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（<strong><code>task.add_done_callback(回调函数)</code></strong>）</p>

<pre><code>get https://www.baidu.com ing
get https://www.sogou.com ing
get https://www.python.org ing
get https://www.asp.net ing
&lt;class '_asyncio.Task'&gt;
&lt;h1&gt;This is a test for https://www.baidu.com&lt;/h1&gt;
&lt;class '_asyncio.Task'&gt;
&lt;h1&gt;This is a test for https://www.python.org&lt;/h1&gt;
&lt;class '_asyncio.Task'&gt;
&lt;h1&gt;This is a test for https://www.sogou.com&lt;/h1&gt;
&lt;class '_asyncio.Task'&gt;
&lt;h1&gt;This is a test for https://www.asp.net&lt;/h1&gt;
2.0168468952178955</code></pre>
<h4 id="2.&#22238;&#35843;&#20989;&#25968;&#20256;&#21442;&#25193;&#23637;">2.&#22238;&#35843;&#20989;&#25968;&#20256;&#21442;&#25193;&#23637;<a class="anchor-link" href="#2.&#22238;&#35843;&#20989;&#25968;&#20256;&#21442;&#25193;&#23637;">&#182;</a></h4><p>实例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;This is a test for&quot;</span>

<span class="c1"># 注意一个东西：通过偏函数传过来的参数在最前面</span>
<span class="k">def</span> <span class="nf">call_back</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
    <span class="c1"># do something</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">(),</span> <span class="n">url</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span>
    <span class="p">]</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># 任务集合</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
        <span class="c1"># task = asyncio.ensure_future(get_html(url))</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
        <span class="c1"># 设置回调函数 （不支持传参数，我们就利用偏函数来传递）</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">call_back</span><span class="p">,</span> <span class="n">url</span><span class="p">))</span>
        <span class="c1"># 添加到任务集合中</span>
        <span class="n">tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="c1"># 批量执行</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(<strong>PS：通过偏函数传过来的参数在最前面</strong>)</p>

<pre><code>&lt;class '_asyncio.Task'&gt;
This is a test for https://www.baidu.com
&lt;class '_asyncio.Task'&gt;
This is a test for https://www.python.org
&lt;class '_asyncio.Task'&gt;
This is a test for https://www.sogou.com
&lt;class '_asyncio.Task'&gt;
This is a test for https://www.asp.net
2.0167236328125</code></pre>
<h3 id="3.5.5.&#24322;&#24120;&#30456;&#20851;">3.5.5.&#24322;&#24120;&#30456;&#20851;<a class="anchor-link" href="#3.5.5.&#24322;&#24120;&#30456;&#20851;">&#182;</a></h3><p>之前说的<code>await task</code>可能得到结果也可能得到异常有些人可能还不明白 ==&gt; 其实你把他看出同步代码（PS：协程的目的就是<strong>像写同步代码一样进行异步编程</strong>）就好理解了，函数执行要么得到结果要么得到返回值</p>
<p>看个异常的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get {url} ing&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span> <span class="o">==</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Exception is over&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span>
    <span class="p">]</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(<strong>和同步代码没差别，可能出异常的部分加个异常捕获即可</strong>)</p>

<pre><code>get https://www.baidu.com ing
get https://www.asp.net ing
get https://www.python.org ing
get https://www.sogou.com ing
Exception is over
0.008000373840332031</code></pre>
<p>再一眼旧版怎么用：（PS：基本差不多，下次全部用新用法了）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get {url} ing&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span> <span class="o">==</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Exception is over&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span>
    <span class="p">]</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># 任务集合</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 批量执行</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<h3 id="&#24120;&#35265;&#24322;&#24120;">&#24120;&#35265;&#24322;&#24120;<a class="anchor-link" href="#&#24120;&#35265;&#24322;&#24120;">&#182;</a></h3><p><strong>Python3调试过程中的常见异常</strong>：<a href="https://www.cnblogs.com/dotnetcrazy/p/9192089.html">https://www.cnblogs.com/dotnetcrazy/p/9192089.html</a></p>
<h4 id="asyncio&#20013;&#24120;&#35265;&#24322;&#24120;">asyncio&#20013;&#24120;&#35265;&#24322;&#24120;<a class="anchor-link" href="#asyncio&#20013;&#24120;&#35265;&#24322;&#24120;">&#182;</a></h4><p>官方文档：<code>https://docs.python.org/3/library/asyncio-exceptions.html</code></p>
<ol>
<li><strong><code>asyncio.TimeoutError(Exception.Error)</code>：</strong><ul>
<li>任务超时引发的异常</li>
</ul>
</li>
<li><strong><code>asyncio.CancelledError(Exception.Error)</code>：</strong><ul>
<li>任务取消引发的异常</li>
</ul>
</li>
<li><code>asyncio.InvalidStateError(Exception.Error)</code>：<ul>
<li><code>Task/Future</code>内部状态无效引发</li>
</ul>
</li>
<li><code>asyncio.IncompleteReadError(Exception.Error)</code>：读取未完成引发的错误:<ul>
<li>不完整: 在到达流结束之前读取字节字符串（读取了不完整的字符串就转换了）</li>
<li>不清楚读多少: 预期读取的字节总数未知</li>
</ul>
</li>
<li><code>asyncio.LimitOverrunError(Exception)</code>：<ul>
<li>超出缓冲区引发的异常</li>
</ul>
</li>
<li><code>asyncio.SendfileNotAvailableError(Exception.ReferenceError.RuntimeError)</code>：<ul>
<li>系统调用不适用于给定的套接字或文件类型（系统调用类型不匹配导致的）</li>
</ul>
</li>
</ol>
<h4 id="Python&#24120;&#35265;&#24322;&#24120;">Python&#24120;&#35265;&#24322;&#24120;<a class="anchor-link" href="#Python&#24120;&#35265;&#24322;&#24120;">&#182;</a></h4><p>有些异常官方没有写进去，我补了一些常用的异常：<code>https://docs.python.org/3/library/exceptions.html</code></p>
<p><strong><code>BaseException</code></strong></p>
<ul>
<li><code>SystemExit</code>：<code>sys.exit()</code>引发的异常（目的：让Python解释器退出）</li>
<li><code>KeyboardInterrupt</code>：用户Ctrl+C终止程序引发的异常</li>
<li><strong><code>GeneratorExit</code></strong>：生成器或者协程关闭的时候产生的异常（<strong>特别注意</strong>）</li>
<li><strong><code>Exception</code></strong>：所有内置异常（非系统退出）或者用户定义异常的基类<ul>
<li><strong><code>asyncio.Error</code></strong><ul>
<li><strong><code>asyncio.CancelledError</code></strong></li>
<li><strong><code>asyncio.TimeoutError</code></strong>：和<code>Exception.OSError.TimeoutError</code>区分开</li>
<li><code>asyncio.InvalidStateError</code>：<code>Task/Future</code>内部状态无效引发</li>
</ul>
</li>
<li><code>asyncio.LimitOverrunError</code>：超出缓冲区引发的异常</li>
<li><code>StopIteration</code>：<code>next()、send()</code>引发的异常：<ul>
<li><code>https://www.cnblogs.com/dotnetcrazy/p/9278573.html#6.Python迭代器</code></li>
</ul>
</li>
<li><code>StopAsyncIteration</code>：<code>__anext__()</code>引发的异常</li>
<li>ArithmeticError<ul>
<li>FloatingPointError</li>
<li>OverflowError</li>
<li>ZeroDivisionError</li>
</ul>
</li>
<li><code>AssertionError</code>：当断言<code>assert</code>语句失败时引发</li>
<li><code>AttributeError</code>：当属性引用或赋值失败时引发</li>
<li>BufferError</li>
<li><code>EOFError</code><ul>
<li><code>asyncio.IncompleteReadError</code>：读取操作未完成引发的错误</li>
</ul>
</li>
<li>ImportError<ul>
<li>ModuleNotFoundError</li>
</ul>
</li>
<li>LookupError<ul>
<li>IndexError</li>
<li>KeyError</li>
</ul>
</li>
<li>MemoryError</li>
<li>NameError<ul>
<li>UnboundLocalError</li>
</ul>
</li>
<li><strong><code>OSError</code></strong>：当系统函数返回与系统相关的错误时引发<ul>
<li>BlockingIOError</li>
<li>ChildProcessError</li>
<li>ConnectionError<ul>
<li>BrokenPipeError</li>
<li>ConnectionAbortedError</li>
<li>ConnectionRefusedError</li>
<li>ConnectionResetError</li>
</ul>
</li>
<li>FileExistsError</li>
<li>FileNotFoundError</li>
<li>InterruptedError</li>
<li>IsADirectoryError</li>
<li>NotADirectoryError</li>
<li>PermissionError</li>
<li>ProcessLookupError</li>
<li><strong><code>TimeoutError</code></strong>：系统函数执行超时时触发</li>
</ul>
</li>
<li><code>ReferenceError</code>：引用错误（对象被资源回收或者删除了）</li>
<li><strong><code>RuntimeError</code></strong>：出错了，但是检测不到错误类别时触发<ul>
<li><code>NotImplementedError</code>：为实现报错（比如调用了某个不存在的子类方法）</li>
<li><code>RecursionError</code>：递归程度太深引发的异常</li>
<li><code>asyncio.SendfileNotAvailableError</code>：系统调用不适用于给定的套接字或文件类型</li>
</ul>
</li>
<li><strong><code>SyntaxError</code></strong>：语法错误时引发（<strong>粘贴代码经常遇到</strong>）<ul>
<li><code>IndentationError</code>：缩进有问题</li>
<li><code>TabError</code>：当缩进包含不一致的制表符和空格使用时引发</li>
</ul>
</li>
<li>SystemError</li>
<li><code>TypeError</code>：类型错误</li>
<li>ValueError<ul>
<li>UnicodeError</li>
<li>UnicodeDecodeError</li>
<li>UnicodeEncodeError</li>
<li>UnicodeTranslateError</li>
</ul>
</li>
<li>Warning</li>
<li>DeprecationWarning</li>
<li>PendingDeprecationWarning</li>
<li>RuntimeWarning</li>
<li>SyntaxWarning</li>
<li>UserWarning</li>
<li>FutureWarning</li>
<li>ImportWarning</li>
<li>UnicodeWarning</li>
<li>BytesWarning</li>
<li>ResourceWarning</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="&#26032;&#35821;&#27861;&#30340;&#35828;&#26126;">&#26032;&#35821;&#27861;&#30340;&#35828;&#26126;<a class="anchor-link" href="#&#26032;&#35821;&#27861;&#30340;&#35828;&#26126;">&#182;</a></h3><p>Net方向的同志记得对比当时写的 <a href="https://mp.weixin.qq.com/s/PY1DZLiT74teuzh2GaA0kw">Python3 与 C# 并发编程之～Net篇：https://www.cnblogs.com/dunitian/p/9419325.html</a></p>
<h4 id="1.&#27010;&#24565;">1.&#27010;&#24565;<a class="anchor-link" href="#1.&#27010;&#24565;">&#182;</a></h4><p>先说说概念：</p>
<ol>
<li><code>event_loop</code>事件循环：<ul>
<li>程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上</li>
<li>当满足事件发生的时候，调用相应的协程函数</li>
</ul>
</li>
<li><code>coroutine</code>协程：<ul>
<li>协程对象，指一个使用<code>async</code>关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象</li>
<li>协程对象需要注册到事件循环，由事件循环调用</li>
</ul>
</li>
<li><code>future</code>对象：<ul>
<li>代表将来执行或没有执行的任务的结果（它和task上没有本质的区别）</li>
</ul>
</li>
<li><code>task</code>任务：<ul>
<li>一个协程对象就是一个原生可以挂起的函数，Task则是对协程进一步封装，其中包含任务的各种状态</li>
<li><strong><code>Task</code>对象是<code>Future</code>的子类</strong>，它将<code>coroutine</code>和<code>Future</code>联系在一起，将<code>coroutine</code>封装成一个<code>Future</code>对象</li>
</ul>
</li>
<li><code>async/await</code>关键字：<ul>
<li>定义协程的关键字，<code>async</code>定义一个协程，<code>await</code>用于挂起阻塞的异步调用接口</li>
<li>类似于<code>yield from</code>（都是在调用方与子协程之间直接建立一个双向通道）</li>
</ul>
</li>
</ol>
<h4 id="2.&#35821;&#27861;">2.&#35821;&#27861;<a class="anchor-link" href="#2.&#35821;&#27861;">&#182;</a></h4><p><strong>为了避免读者混乱于新旧代码的使用，从下面开始就直接使用最新的语法的</strong></p>
<ol>
<li>运行asyncio：<code>asyncio.run(main())</code><ul>
<li>只运行一次(<code>if __name__ == "__main__"</code>)</li>
</ul>
</li>
<li>创建一个任务：<code>asyncio.create_task(func())</code><ul>
<li>Python3.8会多一个name的别名参数</li>
</ul>
</li>
<li>批量执行任务：<code>asyncio.gather(*tasks)</code><ul>
<li>return_exceptions=True可以屏蔽这批任务的异常，并把异常结果返回</li>
<li>如果有类似于(第一个任务完成|第一个异常产生后)进行相应的操作，则推荐<code>asyncio.wait</code></li>
</ul>
</li>
<li>获取loop：<code>asyncio.get_event_loop()</code><ul>
<li>优先考虑：<code>asyncio.get_running_loop()</code>（获取不到会抛异常）</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1"># 如果和旧版本混用，就应该这么写了（麻烦）</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="c1"># no running event loop</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span>
</pre></div>
<p>新语法：</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="o">...</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
<h4 id="3.&#29366;&#24577;">3.&#29366;&#24577;<a class="anchor-link" href="#3.&#29366;&#24577;">&#182;</a></h4><p>Task基本上就是这几个状态（生成器、Future也是）：</p>
<ol>
<li><code>Pending</code>：创建Task，还未执行</li>
<li><code>Running</code>：事件循环正在调用执行任务</li>
<li><code>Done</code>：Task执行完毕</li>
<li><code>Cancelled</code>：Task被取消后的状态</li>
</ol>
<h4 id="4.&#26102;&#24207;&#22270;">4.&#26102;&#24207;&#22270;<a class="anchor-link" href="#4.&#26102;&#24207;&#22270;">&#182;</a></h4><p>Python3.7之前官方贴了张时序图，我们拿来理解上面的话：<code>https://docs.python.org/3.6/library/asyncio-task.html</code></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;计算 {x}+{y}...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{x}+{y}={result}&quot;</span><span class="p">)</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p><img src="../../../images/python/2018-12-07/8.时序.png" alt="8.时序.png"></p>
<h3 id="3.5.4.&#22238;&#35843;&#20989;&#25968;&#65288;&#26032;&#29992;&#27861;&#65289;">3.5.4.&#22238;&#35843;&#20989;&#25968;&#65288;&#26032;&#29992;&#27861;&#65289;<a class="anchor-link" href="#3.5.4.&#22238;&#35843;&#20989;&#25968;&#65288;&#26032;&#29992;&#27861;&#65289;">&#182;</a></h3><p>和旧版本比起来其实就是创建一个<code>task</code>，然后为<code>task</code>添加一个回调函数<code>add_done_callback</code></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get {url} ing&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="k">def</span> <span class="nf">callback_func</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>  <span class="c1"># print(task.result())</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span>
    <span class="p">]</span>
    <span class="c1"># asyncio.create_task来创建一个Task</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="c1"># 给每个任务都加一个回调函数</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback_func</span><span class="p">)</span>
    <span class="c1"># 批量执行任务</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># 返回 result list</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>get https://www.baidu.com ing
get https://www.asp.net ing
get https://www.python.org ing
get https://www.sogou.com ing
&lt;class '_asyncio.Task'&gt;
done
&lt;class '_asyncio.Task'&gt;
done
&lt;class '_asyncio.Task'&gt;
done
&lt;class '_asyncio.Task'&gt;
done
['&lt;h1&gt;This is a test for https://www.baidu.com&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.asp.net&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.python.org&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.sogou.com&lt;/h1&gt;']
2.0189685821533203</code></pre>
<p>注意：<a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler">`add_signal_handler`是loop独有的方法，Task中没有</a>，eg：<code>loop.add_signal_handler(signal.SIGINT, callback_handle, *args)</code></p>
<h3 id="3.5.5.&#24322;&#24120;&#30456;&#20851;&#25193;&#23637;">3.5.5.&#24322;&#24120;&#30456;&#20851;&#25193;&#23637;<a class="anchor-link" href="#3.5.5.&#24322;&#24120;&#30456;&#20851;&#25193;&#23637;">&#182;</a></h3><p>关于批量任务的异常处理：</p>
<ol>
<li>默认：同一批次有一个task产生了异常，这一批次任务就全部结束了</li>
<li><code>return_exceptions=True</code>:不影响其他任务，异常消息也放在结果列表中</li>
<li>当<code>gather</code>被取消的时候，不管True or False，这批次任务全部取消</li>
</ol>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get {url} ing&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span> <span class="o">==</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Exception is over&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="k">def</span> <span class="nf">callback_func</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>  <span class="c1"># print(task.result())</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">,</span>
        <span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span>
    <span class="p">]</span>
    <span class="c1"># asyncio.create_task来创建一个Task</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="c1"># 给每个任务都加一个回调函数</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback_func</span><span class="p">)</span>
    <span class="c1"># 批量执行任务</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># 返回 result list</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>get https://www.baidu.com ing
get https://www.asp.net ing
get https://www.python.org ing
get https://www.sogou.com ing
done
done
done
done
['&lt;h1&gt;This is a test for https://www.baidu.com&lt;/h1&gt;', Exception('Exception is over'), '&lt;h1&gt;This is a test for https://www.python.org&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.sogou.com&lt;/h1&gt;']
2.013272523880005</code></pre>
<h3 id="3.5.6.&#20219;&#21153;&#20998;&#32452;&#12289;&#21462;&#28040;">3.5.6.&#20219;&#21153;&#20998;&#32452;&#12289;&#21462;&#28040;<a class="anchor-link" href="#3.5.6.&#20219;&#21153;&#20998;&#32452;&#12289;&#21462;&#28040;">&#182;</a></h3><h4 id="1.&#20998;&#32452;">1.&#20998;&#32452;<a class="anchor-link" href="#1.&#20998;&#32452;">&#182;</a></h4><p>看个简单的任务分组案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get url for{url}&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">]</span>
    <span class="n">urls2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span><span class="p">]</span>

    <span class="n">tasks1</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls1</span><span class="p">]</span>
    <span class="n">tasks2</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls2</span><span class="p">]</span>

    <span class="c1"># 等待两组都完成，然后返回聚合结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks1</span><span class="p">,</span> <span class="o">*</span><span class="n">tasks2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(两个分组结果被一起放到了list中)</p>

<pre><code>get url forhttps://www.baidu.com
get url forhttps://www.asp.net
get url forhttps://www.python.org
get url forhttps://www.sogou.com
['&lt;h1&gt;This is a test for https://www.baidu.com&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.asp.net&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.python.org&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.sogou.com&lt;/h1&gt;']
2.0099380016326904</code></pre>
<h4 id="2.&#21462;&#28040;">2.&#21462;&#28040;<a class="anchor-link" href="#2.&#21462;&#28040;">&#182;</a></h4><p>如果想要对<code>Group1</code>和<code>Group2</code>进行更多的自定化，可以再包裹一层<code>gather</code>方法：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;get url for{url}&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;This is a test for {url}&lt;/h1&gt;&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">urls1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;https://www.baidu.com&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.asp.net&quot;</span><span class="p">]</span>
    <span class="n">urls2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;https://www.python.org&quot;</span><span class="p">,</span> <span class="s2">&quot;https://www.sogou.com&quot;</span><span class="p">]</span>

    <span class="n">tasks1</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls1</span><span class="p">]</span>
    <span class="n">tasks2</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls2</span><span class="p">]</span>

    <span class="n">group1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks1</span><span class="p">)</span>
    <span class="n">group2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks2</span><span class="p">)</span>

    <span class="c1"># 分组2因为某原因被取消任务了（模拟）</span>
    <span class="n">group2</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="c1"># 等待两组都完成，然后返回聚合结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>get url forhttps://www.baidu.com
get url forhttps://www.asp.net
[['&lt;h1&gt;This is a test for https://www.baidu.com&lt;/h1&gt;', '&lt;h1&gt;This is a test for https://www.asp.net&lt;/h1&gt;'], CancelledError()]
2.0090348720550537</code></pre>
<p>再看个单个任务的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">())</span>

    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 取消task任务</span>
    <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">await</span> <span class="n">task</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;任务已经被取消：{task.cancelled()}&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;任务是因为异常而完成：{task.done()}&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>start...
任务已经被取消：True
任务是因为异常而完成：True
1.0133979320526123</code></pre>
<p>简单说明下：</p>
<ol>
<li><code>task.done()</code>：任务是否完成<ul>
<li>任务完成：<code>task.done() ==&gt; true</code>：<ol>
<li>任务正常完成</li>
<li>触发异常而被标记为任务完成</li>
</ol>
</li>
</ul>
</li>
<li><code>task.cancelled()</code>：用来判断是否成功取消</li>
</ol>
<p>为什么这么说？看看源码：</p>
<div class="highlight"><pre><span></span><span class="c1"># 完成包含了正常+异常</span>
<span class="k">if</span> <span class="n">outer</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
    <span class="c1"># 把因为异常完成的任务打个标记</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fut</span><span class="o">.</span><span class="n">cancelled</span><span class="p">():</span>
        <span class="n">fut</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span> <span class="c1"># 标记检索的异常</span>
</pre></div>
<p>PS：官方推荐<strong><code>asyncio.all_tasks</code></strong>(loop中尚未完成的Task集合):</p>
<ul>
<li>原来是通过：<code>asyncio.Task.all_tasks</code>来获取(返回loop的所有Task集合)</li>
</ul>
<h3 id="wait_for-and-wait">wait_for and wait<a class="anchor-link" href="#wait_for-and-wait">&#182;</a></h3><h4 id="1.&#19968;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait_for)">1.&#19968;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait_for)<a class="anchor-link" href="#1.&#19968;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait_for)">&#182;</a></h4><p>超时等待：<strong><code>asyncio.wait_for(task, timeout)</code></strong></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Cancel&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;超时取消&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>start...
超时取消
2.007002115249634</code></pre>
<h4 id="2.&#22810;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait)">2.&#22810;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait)<a class="anchor-link" href="#2.&#22810;&#20010;&#20219;&#21153;&#38480;&#26102;&#31561;&#24453;(wait)">&#182;</a></h4><p><code>wait</code>是比<code>gather</code>更底层的api，比如现在这个<strong>多任务限时等待</strong><code>gather</code>并不能满足:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end...&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

    <span class="c1"># 已完成的任务（包含异常），未完成的任务</span>
    <span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># 任务总数（我用了3种表示）PS：`all_tasks()`的时候记得去除main的那个</span>
    <span class="k">print</span><span class="p">(</span>
        <span class="n">f</span><span class="s2">&quot;任务总数：{len(tasks)}=={len(done)+len(pending)}=={len(asyncio.Task.all_tasks())-1}&quot;</span>
    <span class="p">)</span>
    <span class="c1"># 所有未完成的task：asyncio.all_tasks()，记得去掉run(main())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;未完成Task:{len(pending)}=={len(asyncio.all_tasks()) - 1}&quot;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">))</span>
    <span class="c1"># for task in done:</span>
        <span class="c1"># print(await task)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>start...
start...
start...
start...
start...
start...
start...
start...
start...
start...
end...
end...
end...
任务总数：10==10==10
未完成Task:7==7
[0, 1, 2]
2.0071778297424316</code></pre>
<h4 id="wait&#30340;&#25193;&#23637;">wait&#30340;&#25193;&#23637;<a class="anchor-link" href="#wait&#30340;&#25193;&#23637;">&#182;</a></h4><p>用法其实和Future一样（<a href="https://mp.weixin.qq.com/s/UeBOJlXwKc24zwSD2-bzWw">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#Future对象</a>），这边就当再普及下新语法了</p>
<h5 id="&#31532;&#19968;&#20010;&#20219;&#21153;&#25191;&#34892;&#23436;&#25104;&#21017;&#32467;&#26463;&#27492;&#25209;&#27425;&#20219;&#21153;">&#31532;&#19968;&#20010;&#20219;&#21153;&#25191;&#34892;&#23436;&#25104;&#21017;&#32467;&#26463;&#27492;&#25209;&#27425;&#20219;&#21153;<a class="anchor-link" href="#&#31532;&#19968;&#20010;&#20219;&#21153;&#25191;&#34892;&#23436;&#25104;&#21017;&#32467;&#26463;&#27492;&#25209;&#27425;&#20219;&#21153;">&#182;</a></h5><p>项目里经常有这么一个场景：<code>同时调用多个同效果的API，有一个返回后取消其他请求</code>,看个引入案例</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;start...task{i}&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;end...task{i}&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;ok&quot;</span>

<span class="c1"># 第一个任务执行完成则结束此批次任务</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

    <span class="c1"># 项目里经常有这么一个场景：同时调用多个同效果的API，有一个返回后取消其他请求</span>
    <span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
        <span class="n">tasks</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">FIRST_COMPLETED</span><span class="p">)</span>

    <span class="c1"># print(await asyncio.gather(*done))</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">await</span> <span class="n">task</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>start...task0
start...task1
start...task2
start...task3
start...task4
start...task5
start...task6
start...task7
start...task8
start...task9
end...task0
ok
0.017002105712890625</code></pre>
<p>课后拓展：(<strong><code>asyncio.shield</code>保护等待对象不被取消</strong>)
<a href="https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation">https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation</a></p>
<p><strong>下级预估：旧代码兼容、同步语、Socket新用</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="&#20195;&#30721;&#31572;&#30097;">&#20195;&#30721;&#31572;&#30097;<a class="anchor-link" href="#&#20195;&#30721;&#31572;&#30097;">&#182;</a></h3><p>之前有人问我，这个<code>asyncio.get_running_loop()</code>到底是用还是不用？为什么一会<code>asyncio.get_event_loop()</code>一会又是<code>asyncio.get_running_loop()</code>，一会是<code>loop.run_until_complete()</code>一会又是<code>asyncio.run()</code>的，有点混乱了。</p>
<p>之前逆天简单的提了一下，可能说的还是不太详细，这边再举几个例子说说：</p>
<p>首先：如果你用的是<strong><code>Python3.7</code>之前的版本，那么你用不到<code>loop = asyncio.get_running_loop()</code>和<code>asyncio.run()</code>的</strong></p>
<p>如果是<strong>老版本</strong>你就使用<code>asyncio.get_event_loop()</code>来获取<code>loop</code>，用<code>loop.run_until_complete()</code>来运行：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start ...&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end ...&quot;</span><span class="p">)</span>

<span class="c1"># 如果你用`get_running_loop`就不要和`loop.run_until_complete`混用</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">test</span><span class="p">())</span>
</pre></div>
<p>输出：（混用需要捕获Runtime的异常）</p>

<pre><code>start ...
end ...</code></pre>
<p>上节课说使用<code>asyncio.get_running_loop()</code>麻烦的情景是这个：（这种情况倒不如直接<code>asyncio.get_event_loop()</code>获取loop了）</p>
<div class="highlight"><pre><span></span><span class="c1"># 如果和旧版本混用，就应该这么写了（麻烦）</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">test</span><span class="p">())</span>
</pre></div>
<p>官方推荐的新语法是这样的：(&gt;=<code>Python3.7</code>)</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="o">...</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
<p>PS：记住一句就行：<strong><code>asyncio.get_running_loop()</code>和<code>asyncio.run()</code>成对出现</strong></p>
<p>可以这么理解：<code>asyncio.run</code>里会创建对应的<code>loop</code>，所以你才能获取正在运行的<code>loop</code>：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/asyncio/runners.py</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">_get_running_loop</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;无法从正在运行的事件循环中调用asyncio.run()&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coroutines</span><span class="o">.</span><span class="n">iscoroutine</span><span class="p">(</span><span class="n">main</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{!r}应该是一个协程&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">main</span><span class="p">))</span>

    <span class="c1"># 创建一个新的事件循环</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">events</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="c1"># 设置事件循环</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="c1"># 是否调试运行（默认否）</span>
        <span class="k">return</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="c1"># 等待运行</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_cancel_all_tasks</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="c1"># 取消其他任务</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">events</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p><strong>就是怕大家混乱，上节课开始就直接使用的最新语法，旧语法文章里尽量不使用了，本节也是</strong></p>
<h3 id="3.5.7.&#20860;&#23481;&#26087;&#20195;&#30721;-or-&#36816;&#34892;&#38459;&#22622;&#20195;&#30721;">3.5.7.&#20860;&#23481;&#26087;&#20195;&#30721; or &#36816;&#34892;&#38459;&#22622;&#20195;&#30721;<a class="anchor-link" href="#3.5.7.&#20860;&#23481;&#26087;&#20195;&#30721;-or-&#36816;&#34892;&#38459;&#22622;&#20195;&#30721;">&#182;</a></h3><p>部分可以参考官方文档：<code>https://docs.python.org/3/library/asyncio-eventloop.html</code></p>
<p>学了协程<code>GIL</code>的问题其实也不是多大的事情了，多进程+协程就可以了，<code>asyncio</code>现在也提供了线程安全的<code>run</code>方法：<strong><code>asyncio.run_coroutine_threadsafe(coro)</code></strong>（也算是对GIL给出的官方解决方法了）</p>
<h4 id="1.&#21327;&#31243;-and-&#32447;&#31243;&#27744;">1.&#21327;&#31243; and &#32447;&#31243;&#27744;<a class="anchor-link" href="#1.&#21327;&#31243;-and-&#32447;&#31243;&#27744;">&#182;</a></h4><p>前面我们说过了并发编程（线程+进程）的通用解决方案：<a href="https://mp.weixin.qq.com/s/UeBOJlXwKc24zwSD2-bzWw" target="_blank">并发编程：concurrent.futures专栏</a></p>
<p><code>asyncio</code>框架虽然几乎包含了所有常用功能，但毕竟是新事物，旧代码怎么办？协程只是单线程工作，理论上不能使用阻塞代码，那库或者api只能提供阻塞的调用方式怎么办？ ~ 不用慌，可以使用官方提供的兼容方法，先看个案例：</p>
<h5 id="1.&#22238;&#39038;&#19979;&#19968;&#36215;&#30340;&#36890;&#29992;&#26041;&#26696;&#65306;">1.&#22238;&#39038;&#19979;&#19968;&#36215;&#30340;&#36890;&#29992;&#26041;&#26696;&#65306;<a class="anchor-link" href="#1.&#22238;&#39038;&#19979;&#19968;&#36215;&#30340;&#36890;&#29992;&#26041;&#26696;&#65306;">&#182;</a></h5><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># old main</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1"># 注意：future和asyncio.future是不一样的</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">main</span><span class="p">()</span>  <span class="c1"># old</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（注意：<code>future</code>和<code>asyncio.future</code>不是一个东西，只是类似而已）</p>

<pre><code>333333283333335000000
15.230607032775879</code></pre>
<h5 id="2.&#20860;&#23481;&#29256;&#26032;&#29992;&#27861;&#65306;">2.&#20860;&#23481;&#29256;&#26032;&#29992;&#27861;&#65306;<a class="anchor-link" href="#2.&#20860;&#23481;&#29256;&#26032;&#29992;&#27861;&#65306;">&#182;</a></h5><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>


<span class="c1"># 模拟一个耗时操作</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span><span class="p">))</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 获取loop</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1"># 新版兼任代码</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>  <span class="c1"># new</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（不谈其他的，至少运行速度快了）</p>

<pre><code>333333283333335000000
15.283994913101196</code></pre>
<h5 id="&#28304;&#30721;&#20998;&#26512;">&#28304;&#30721;&#20998;&#26512;<a class="anchor-link" href="#&#28304;&#30721;&#20998;&#26512;">&#182;</a></h5><p>我们来看看<code>run_in_executor</code>的内部逻辑是啥：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseEventLoop</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run_in_executor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executor</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># 检查loop是否关闭，如果关闭就抛`RuntimeError`异常</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_callback</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;run_in_executor&#39;</span><span class="p">)</span>
        <span class="c1"># 如果不传一个executor,就会使用默认的executor</span>
        <span class="c1"># 换句话说：你可以不传`线程池`</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_executor</span>
            <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">executor</span> <span class="o">=</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_default_executor</span> <span class="o">=</span> <span class="n">executor</span>
        <span class="c1"># 把`concurrent.futures.Future`对象封装成`asyncio.futures.Future`对象</span>
        <span class="k">return</span> <span class="n">futures</span><span class="o">.</span><span class="n">wrap_future</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
<p>看完源码就发现，代码还可以进一步简化：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 模拟一个耗时操作</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span><span class="p">))</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 获取loop</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># 新版兼任代码</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>333333283333335000000
15.367998838424683</code></pre>
<p><strong>PS：协程里面不应该出现传统的阻塞代码，如果只能用那些代码，那么这个就是一个兼任的措施了</strong></p>
<h4 id="2.&#22238;&#35843;&#25193;&#23637;">2.&#22238;&#35843;&#25193;&#23637;<a class="anchor-link" href="#2.&#22238;&#35843;&#25193;&#23637;">&#182;</a></h4><p>这个没有之前讲的那些常用，就当了解下，框架里面碰到不至于懵逼：</p>
<ol>
<li>Task执行完后执行：<strong><code>add_done_callback(回调函数)</code></strong><ul>
<li><strong><code>task.add_done_callback()</code></strong> or <code>loop.add_done_callback()</code></li>
<li>想要传参数可以使用：<code>functools.partial(call_back, url)</code></li>
<li>PS：通过偏函数传过来的参数在最前面：<code>call_back(url,task)</code></li>
</ul>
</li>
<li>尽快执行：<strong><code>call_soon(callback,*args)</code></strong><ul>
<li><code>loop.call_soon()</code>、线程安全：<code>loop.call_soon_threadsafe()</code></li>
<li>可以看成是<code>loop.call_later(0,callback,*args)</code></li>
<li>一般临时插入一个任务的时候会用到</li>
</ul>
</li>
<li>指定时间后执行：<strong><code>loop.call_later(delay,callback,*args)</code></strong><ul>
<li>延迟可以是int或float，以秒为单位（相对于当前时间）</li>
<li>返回的对象可以使用cancel()方法来取消任务</li>
</ul>
</li>
<li>指定协程时间后执行：<strong><code>loop.call_at(绝对时间,callback,*args)</code></strong><ul>
<li>和call_later差不多，时间使用绝对时间(这个绝对时间是loop的time()方法)</li>
</ul>
</li>
</ol>
<p>注意点：<strong>首先要保证任务执行前loop不断开</strong>，比如你<code>call_later(2,xxx)</code>，这时候loop退出了，那么任务肯定完成不了</p>
<p>这个比较简单，看个案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;start {name}...&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;end {name}...&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 正在执行某个任务</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># 插入一个更要紧的任务</span>
    <span class="c1"># loop.call_later(0, callback, *args)</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task1&quot;</span><span class="p">)</span>

    <span class="c1"># 多少秒后执行</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task2&quot;</span><span class="p">)</span>

    <span class="c1"># 内部时钟时间</span>
    <span class="n">task3</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_at</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task3&quot;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task1</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task2</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">task3</span><span class="p">))</span>

    <span class="c1"># 保证loop在执行完毕后才关闭</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(<code>回调函数一般都是普通函数</code>)</p>

<pre><code>&lt;class 'asyncio.events.Handle'&gt;
&lt;class 'asyncio.events.TimerHandle'&gt;
&lt;class 'asyncio.events.TimerHandle'&gt;
start task1...
end task1...
start task2...
end task2...
start task3...
end task3...
4.9966819286346436</code></pre>
<p>PS：关于返回值的说明可以看官方文档：<code>https://docs.python.org/3/library/asyncio-eventloop.html#callback-handles</code></p>
<p>然后说下<strong><code>call_later</code></strong>（这个执行过程会<strong>按照时间排个先后顺序</strong>，然后再批次运行）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 回调函数一般都是普通函数</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

    <span class="c1"># 新版本限制了时间不能超过24h（防止有些人当定时任务来乱用）</span>
    <span class="c1"># 这个执行过程会安装时间排个先后顺序，然后再批次运行</span>
    <span class="n">task4</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task2-4&quot;</span><span class="p">)</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task2-2&quot;</span><span class="p">)</span>
    <span class="n">task3</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task2-3&quot;</span><span class="p">)</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;task2-1&quot;</span><span class="p">)</span>
    <span class="c1"># 取消测试</span>
    <span class="n">task4</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="c1"># close是直接丢弃任务然后关闭loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>  <span class="c1"># 等任务执行完成结束任务 loop.stop()</span>

    <span class="c1"># run内部运行的是run_until_complete，而run_until_complete内部运行的是run_forever</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（<code>asyncio.get_running_loop()</code>不要和旧代码混用）</p>

<pre><code>task2-1
task2-2
task2-3
4.009201526641846</code></pre>
<p><strong>PS：<code>run</code>内部运行的是<code>run_until_complete</code>，而<code>run_until_complete</code>内部运行的是<code>run_forever</code></strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="Task&#31572;&#30097;">Task&#31572;&#30097;<a class="anchor-link" href="#Task&#31572;&#30097;">&#182;</a></h3><p>从开始说新语法之后，我们创建任务都直接用<code>asyncio.create_task</code>来包裹一层，有人问我这个<code>Task</code>除了是<code>Future</code>的子类外，有啥用？为啥不直接使用<code>Future</code>呢？貌似也没语法啊？</p>
<p>看一个案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 不是协程就加个装饰器</span>
<span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;this is a test&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test_async</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;this is a async test&quot;</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 传入一个协程对象，返回一个task</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">())</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test_async</span><span class="p">())</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>this is a test
this is a async test
1.0070011615753174</code></pre>
<p>我们来看看<code>asyncio.create_task</code>的源码：（关键在<code>Task</code>类）</p>
<div class="highlight"><pre><span></span><span class="c1"># 传入一个协程对象，返回一个Task对象</span>
<span class="k">def</span> <span class="nf">create_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_factory</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># look：核心点</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">_source_traceback</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">task</span><span class="o">.</span><span class="n">_source_traceback</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">task</span>
</pre></div>
<p>看看核心类<code>Task</code>：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">futures</span><span class="o">.</span><span class="n">_PyFuture</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="c1"># 安排了一个尽快执行的回调方法：self.__step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__step</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
       <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># 协程初始化（生成器或者协程初始化 next(xxx））</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">coro</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_must_cancel</span><span class="p">:</span>
                <span class="c1"># 在停止之前取消任务</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_must_cancel</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">futures</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 拿到了协程/生成器的结果</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">futures</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>  <span class="c1"># I.e., Future.cancel(self).</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">raise</span>
    <span class="o">...</span>
</pre></div>
<p>PS：那么很<strong>明显了，<code>Task</code>的作用就类似于<code>future</code>和<code>协程</code>的中间人了</strong>（屏蔽某些差异）</p>
<h3 id="3.5.8.Socket&#26032;&#29992;&#27861;">3.5.8.Socket&#26032;&#29992;&#27861;<a class="anchor-link" href="#3.5.8.Socket&#26032;&#29992;&#27861;">&#182;</a></h3><p>官方文档：<a href="https://docs.python.org/3/library/asyncio-stream.html">https://docs.python.org/3/library/asyncio-stream.html</a></p>
<p><code>asyncio</code>实现了<code>TCP、UDP、SSL</code>等协议，<code>aiohttp</code>则是基于<code>asyncio</code>实现的HTTP框架，我们简单演示一下（PS：网络通信基本上都是使用<code>aiohttp</code>）</p>
<h4 id="1.&#31616;&#21333;&#26696;&#20363;">1.&#31616;&#21333;&#26696;&#20363;<a class="anchor-link" href="#1.&#31616;&#21333;&#26696;&#20363;">&#182;</a></h4><p>服务端：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">client_reader</span><span class="p">,</span> <span class="n">client_writer</span><span class="p">):</span>
    <span class="c1"># 没有数据就阻塞等（主线程做其他事情去了）</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">await</span> <span class="n">client_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>

    <span class="n">client_writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;骊山语罢清宵半,泪雨霖铃终不怨</span><span class="se">\n</span><span class="s2">何如薄幸锦衣郎,比翼连枝当日愿&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
    <span class="n">await</span> <span class="n">client_writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>  <span class="c1"># 等待缓冲区（缓冲区没占满就直接返回）</span>
    <span class="n">client_writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭连接</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Server已经启动，端口：8080&quot;</span><span class="p">)</span>
    <span class="c1"># 实现了协程方法`__aenter__`和`__aexit__`的可以使用`async with`</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">server</span><span class="p">:</span>
        <span class="c1"># async def serve_forever(self):pass ==&gt; use await</span>
        <span class="n">await</span> <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>  <span class="c1"># 异步方法</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>客户端：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;人生若只如初见,何事秋风悲画扇</span><span class="se">\n</span><span class="s2">等闲变却故人心,却道故人心易变&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出图示：
<img src="../../../images/python/2018-12-07/9.conn.png" alt="9.conn.png"></p>
<h4 id="2.HTTP&#26696;&#20363;">2.HTTP&#26696;&#20363;<a class="anchor-link" href="#2.HTTP&#26696;&#20363;">&#182;</a></h4><p>再举个HTTP的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;get_html </span><span class="si">%s</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">host</span><span class="p">)</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s2">Host: {host}</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
    <span class="n">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>  <span class="c1"># 等待缓冲区</span>

    <span class="n">html_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">async</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">html_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>

    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭连接</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">html_list</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dotnetcrazy.cnblogs.com&#39;</span><span class="p">,</span> <span class="s1">&#39;dunitian.cnblogs.com&#39;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">html_list</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">html_list</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>get_html dotnetcrazy.cnblogs.com...
get_html dunitian.cnblogs.com...
[html内容省略,html内容省略]
5.092018604278564</code></pre>
<p>GIF过程图：
<img src="../../../images/python/2018-12-07/10.过程.gif" alt="10.过程.gif"></p>
<p>PS：（后面会继续说的）</p>
<ol>
<li><strong>实现了协程方法<code>__anext__</code>的可以使用<code>async for</code></strong></li>
<li><strong>实现了协程方法<code>__aenter__</code>和<code>__aexit__</code>的可以使用<code>async with</code></strong></li>
</ol>
<h4 id="3.&#28304;&#30721;&#20998;&#26512;">3.&#28304;&#30721;&#20998;&#26512;<a class="anchor-link" href="#3.&#28304;&#30721;&#20998;&#26512;">&#182;</a></h4><p>还记得之前IO多路复用的时候自己写的<code>非阻塞Server</code>不，简单梳理下流程，然后咱们再一起看看<code>asyncio</code>对应的源码：</p>
<ol>
<li>设置<code>Socket</code>为非阻塞（<strong><code>socket.setblocking(False)</code></strong>）</li>
<li>利用轮询用来监视文件描述符<code>fd</code>（<strong><code>register</code></strong>）</li>
<li>对可读写的<code>socket</code>进行相应操作</li>
<li>取消轮询的监听（<strong><code>unregister</code></strong>）</li>
</ol>
<p>看看<code>await asyncio.open_connection(ip,port)</code>的源码：</p>
<div class="highlight"><pre><span></span><span class="c1"># asyncio.streams.py</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">open_connection</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">_DEFAULT_LIMIT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">StreamReaderProtocol</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>
    <span class="c1"># 核心点</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">StreamWriter</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span>
</pre></div>
<p>发现，其实内部核心在<code>loop.create_connection</code>中</p>
<div class="highlight"><pre><span></span><span class="c1"># asyncio.base_events.py</span>
<span class="c1"># 连接TCP服务器</span>
<span class="k">class</span> <span class="nc">BaseEventLoop</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">def</span> <span class="nf">create_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">protocol_factory</span><span class="p">,</span>
                                <span class="n">host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="o">*</span><span class="p">,</span>
                                <span class="n">ssl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">family</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                <span class="n">sock</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">local_addr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">server_hostname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="c1"># 主要逻辑</span>
        <span class="k">if</span> <span class="n">host</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">port</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exceptions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># 主要逻辑</span>
            <span class="k">for</span> <span class="n">family</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">cname</span><span class="p">,</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="n">family</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">proto</span><span class="p">)</span>
                    <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 1.设置非阻塞 &lt;&lt;&lt;&lt; look</span>
                    <span class="k">if</span> <span class="n">local_addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">laddr</span> <span class="ow">in</span> <span class="n">laddr_infos</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">laddr</span><span class="p">)</span> <span class="c1"># 端口绑定</span>
                                <span class="k">break</span>
                            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="s1">&#39;error while attempting to bind on &#39;</span>
                                       <span class="n">f</span><span class="s1">&#39;address {laddr!r}: &#39;</span>
                                       <span class="n">f</span><span class="s1">&#39;{exc.strerror.lower()}&#39;</span><span class="p">)</span>
                                <span class="n">exc</span> <span class="o">=</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                                <span class="n">exceptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                            <span class="n">sock</span> <span class="o">=</span> <span class="bp">None</span>
                            <span class="k">continue</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;connect </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
                    <span class="c1"># 在selector_events中</span>
                    <span class="n">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="c1"># &lt;&lt;&lt; look</span>
                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="n">exceptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
</pre></div>
<p>发现源码中<strong>设置了socket为非阻塞</strong>，调用了<code>sock_connect</code></p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">sock_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;连接远程socket地址(协程方法)&quot;&quot;&quot;</span>
        <span class="c1"># 非阻塞检查</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="ow">and</span> <span class="n">sock</span><span class="o">.</span><span class="n">gettimeout</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the socket must be non-blocking&quot;</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="n">fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock_connect</span><span class="p">(</span><span class="n">fut</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">await</span> <span class="n">fut</span>

<span class="k">def</span> <span class="nf">_sock_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fut</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span> <span class="c1"># 获取socket的文件描述符 &lt;&lt;&lt; look</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">BlockingIOError</span><span class="p">,</span> <span class="n">InterruptedError</span><span class="p">):</span>
            <span class="c1"># 设置future的回调函数_sock_connect_done（用来注销的）&lt;&lt;&lt; look</span>
            <span class="n">fut</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock_connect_done</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span>
            <span class="c1"># 注册selector.register</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock_connect_cb</span><span class="p">,</span> <span class="n">fut</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">fut</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
<p>先看下<code>sock_connect</code>中调用的<code>add_writer</code>(注册)</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;添加一个写的回调&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_fd_no_transport</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_add_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_WRITE</span><span class="p">,</span>
                                    <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">handle</span><span class="p">))</span> <span class="c1"># selector.register</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">modify</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_WRITE</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">handle</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre></div>
<p>再看下<code>sock_connect</code>中设置的回调函数<code>_sock_connect_done</code>（注销）</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_sock_connect_done</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fut</span><span class="p">):</span>
    <span class="c1"># 取消注册selector.unregister</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">remove_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;移除写的回调&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_fd_no_transport</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_remove_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">data</span>
        <span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_WRITE</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="c1"># 注销 &lt;&lt;&lt; look</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">modify</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
<p><strong>PS：嵌套的非常深，而且底层代码一致在变（Python3.6到Python3.7这个新小更新就变化很大）</strong></p>
<h3 id="&#20851;&#20110;&#28304;&#30721;&#30340;&#35828;&#26126;">&#20851;&#20110;&#28304;&#30721;&#30340;&#35828;&#26126;<a class="anchor-link" href="#&#20851;&#20110;&#28304;&#30721;&#30340;&#35828;&#26126;">&#182;</a></h3><p>之前并发编程的基础知识已经讲的很清楚了，也分析了很多源码，你可以自己去拓展一下（<code>Python3</code>的<code>asyncio</code>模块的源码一直在优化改进的路上）我这边就不一一分析了(源码很乱，估计几个版本后会清晰，现在是多层混套用)，你可以参考部分源码解析：<a href="https://github.com/lotapp/cpython3/tree/master/Lib/asyncio">https://github.com/lotapp/cpython3/tree/master/Lib/asyncio</a>
<img src="../../../images/python/2018-12-07/7.源码.png" alt="7.源码.png"></p>
<p>课后拓展：</p>

<pre><code>https://docs.python.org/3/library/asyncio-protocol.html#examples
https://docs.python.org/3/library/asyncio-eventloop.html#creating-network-servers</code></pre>
<p>下节预估：<strong>同步与通信、aiohttp版爬虫</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="3.5.9.&#21516;&#27493;&#19982;&#36890;&#20449;">3.5.9.&#21516;&#27493;&#19982;&#36890;&#20449;<a class="anchor-link" href="#3.5.9.&#21516;&#27493;&#19982;&#36890;&#20449;">&#182;</a></h3><p>官方文档：</p>

<pre><code>https://docs.python.org/3/library/asyncio-sync.html
https://docs.python.org/3/library/asyncio-queue.html</code></pre>
<p>写在前面：</p>
<ol>
<li><strong>下面的方式不是线程安全的（协程就一个线程）</strong></li>
<li><strong>这些同步原语的方法不接受超时参数; 使用asyncio.wait_for(协程方法,超时时间)函数执行超时操作</strong></li>
<li><code>asyncio</code>具有以下基本同步原语：<code>Lock、Event、Condition、Semaphore、BoundedSemaphore</code></li>
</ol>
<h4 id="1.&#24341;&#23548;&#31034;&#20363;">1.&#24341;&#23548;&#31034;&#20363;<a class="anchor-link" href="#1.&#24341;&#23548;&#31034;&#20363;">&#182;</a></h4><h5 id="1.1.old-code">1.1.old code<a class="anchor-link" href="#1.1.old-code">&#182;</a></h5><p>先看个原来的引导案例：估计的结果是0，而不借助lock得出的结果往往出乎意料</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">num</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000000</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start submit...&quot;</span><span class="p">)</span>
        <span class="n">future1</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">future2</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">future1</span><span class="p">,</span> <span class="n">future2</span><span class="p">])</span>  <span class="c1"># wait some time</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end submit...&quot;</span><span class="p">)</span>
    <span class="k">global</span> <span class="n">num</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">main</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;time:{time.time()-start_time}&quot;</span><span class="p">)</span>
</pre></div>
<p>输出：(但是代码并不是线程安全的，所以结果往往不是我们想要的）</p>

<pre><code>start submit...
end submit...
82705
time:5.032064199447632</code></pre>
<h5 id="1.2.new-code">1.2.new code<a class="anchor-link" href="#1.2.new-code">&#182;</a></h5><p>再看看协程的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">num</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000000</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;start tasks...&quot;</span><span class="p">)</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;end tasks...&quot;</span><span class="p">)</span>

    <span class="k">global</span> <span class="n">num</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;time:{time.time()-start_time}&quot;</span><span class="p">)</span>
</pre></div>
<p>输出：（就一个线程，当然安全）</p>

<pre><code>start tasks...
end tasks...
0
time:4.860997438430786</code></pre>
<h5 id="1.3.&#27880;&#24847;&#28857;">1.3.&#27880;&#24847;&#28857;<a class="anchor-link" href="#1.3.&#27880;&#24847;&#28857;">&#182;</a></h5><p>PS：<strong>你使用协程的兼容代码，并不能解决线程不安全的问题</strong></p>

<pre><code>import asyncio
import concurrent.futures

num = 0

def test(i):
    global num
    for _ in range(10000000):
        num += i

async def main():
    # 获取当前loop
    loop = asyncio.get_running_loop()

    with concurrent.futures.ThreadPoolExecutor() as executor:
        print("start submit...")
        future1 = loop.run_in_executor(executor, test, 1)
        future2 = loop.run_in_executor(executor, test, -1)
        # await asyncio.wait([future1,future2])
        await asyncio.gather(future1, future2)
        print("end submit...")
    global num
    print(num)

if __name__ == "__main__":
    import time
    start_time = time.time()

    asyncio.run(main())

    print(f"time:{time.time()-start_time}")</code></pre>
<p>输出：</p>

<pre><code>start submit...
end submit...
-1411610
time:5.0279998779296875</code></pre>
<h4 id="2.&#20026;&#20160;&#20040;&#38656;&#35201;&#21516;&#27493;&#26426;&#21046;&#65311;">2.&#20026;&#20160;&#20040;&#38656;&#35201;&#21516;&#27493;&#26426;&#21046;&#65311;<a class="anchor-link" href="#2.&#20026;&#20160;&#20040;&#38656;&#35201;&#21516;&#27493;&#26426;&#21046;&#65311;">&#182;</a></h4><p>咋一看，单线程不用管线程安全啥的啊，要啥同步机制？其实在业务场景里面还是会出现诸如重复请求的情况，这个时候就需要一个同步机制了：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 用来存放页面缓存</span>
<span class="n">cache_dict</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># 模拟一个获取html的过程</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 每次网络访问，时间其实不确定的</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h2&gt;{url}&lt;/h2&gt;&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 如果缓存存在，则返回缓存的页面</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">cache_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cache_dict</span><span class="p">[</span><span class="n">url</span><span class="p">]</span>
    <span class="c1"># 否则获取页面源码并缓存</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">cache_dict</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">html</span>
    <span class="k">return</span> <span class="n">html</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parse_js</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># do somthing</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parse_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># do somthing</span>
    <span class="k">return</span> <span class="n">html</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 提交两个Task任务</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">parse_js</span><span class="p">(</span><span class="s2">&quot;www.baidu.com&quot;</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">parse_html</span><span class="p">(</span><span class="s2">&quot;www.baidu.com&quot;</span><span class="p">))</span>
    <span class="c1"># 等待任务结束</span>
    <span class="n">result_list</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：(<code>fetch</code>方法访问了两次 ==&gt; 两次网络请求)</p>

<pre><code>2
3
[22, '&lt;h2&gt;www.baidu.com&lt;/h2&gt;']
3.0100157260894775</code></pre>
<p><strong>简单说明：<code>baidu.com</code>一开始没缓存，那当解析js和解析html的任务提交时，就会进行两次网络请求（网络IO比较耗时），这样更容易触发反爬虫机制</strong></p>
<h4 id="3.Lock&#65288;&#20114;&#26021;&#38145;&#65289;">3.Lock&#65288;&#20114;&#26021;&#38145;&#65289;<a class="anchor-link" href="#3.Lock&#65288;&#20114;&#26021;&#38145;&#65289;">&#182;</a></h4><p>线程相关的Lock复习：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.1.线程同步~互斥锁Lock">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.1.线程同步~互斥锁Lock</a></p>
<p>协程是线程安全的，那么这个<code>Lock</code>肯定是和<code>多线程/进程</code>里面的<code>Lock</code>是不一样的，我们先看一下提炼版的源码：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Lock</span><span class="p">(</span><span class="n">_ContextManagerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">loop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

    <span class="n">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 改变标识</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="o">...</span>
</pre></div>
<p><strong>PS：源码看完秒懂了，asyncio里面的lock其实就是一个标识而已</strong></p>
<p>修改一下上面的例子：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 用来存放页面缓存</span>
<span class="n">cache_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">lock</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># 你可以试试在这边直接写`asyncio.Lock()`</span>

<span class="c1"># 模拟一个获取html的过程</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 每次网络访问，时间其实不确定的</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;h2&gt;{url}&lt;/h2&gt;&quot;</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="c1"># 如果缓存存在，则返回缓存的页面</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">cache_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cache_dict</span><span class="p">[</span><span class="n">url</span><span class="p">]</span>
        <span class="c1"># 否则获取页面源码并缓存</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">cache_dict</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">html</span>
        <span class="k">return</span> <span class="n">html</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parse_js</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># do somthing</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parse_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># do somthing</span>
    <span class="k">return</span> <span class="n">html</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">lock</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  <span class="c1"># 如果在开头就定义，那么lock的loop和方法的loop就会不一致了</span>

    <span class="c1"># 提交两个Task任务</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">parse_js</span><span class="p">(</span><span class="s2">&quot;www.baidu.com&quot;</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">parse_html</span><span class="p">(</span><span class="s2">&quot;www.baidu.com&quot;</span><span class="p">))</span>
    <span class="c1"># 等待任务结束</span>
    <span class="n">result_list</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出:(<code>fetch</code>方法访问了1次 ==&gt; 1次网络请求)</p>

<pre><code>3
[22, '&lt;h2&gt;www.baidu.com&lt;/h2&gt;']
3.0020127296447754</code></pre>
<h4 id="4.Semaphore&#65288;&#20449;&#21495;&#37327;&#65289;">4.Semaphore&#65288;&#20449;&#21495;&#37327;&#65289;<a class="anchor-link" href="#4.Semaphore&#65288;&#20449;&#21495;&#37327;&#65289;">&#182;</a></h4><p>线程篇<code>Semaphore</code>：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.5.线程同步~信号量Semaphore(互斥锁的高级版)">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.5.线程同步~信号量Semaphore(互斥锁的高级版)</a></p>
<p>这个用的比较多，简单回顾下之前讲的概念案例：</p>
<p><strong>通俗讲就是：在互斥锁的基础上封装了下，实现一定程度的并行</strong></p>
<p>举个例子，以前使用互斥锁的时候：（厕所就一个坑位，必须等里面的人出来才能让另一个人上厕所）</p>
<p><img src="../../../images/python/2018-08-23/3.互斥锁.png" alt="3.互斥锁.png"></p>
<p>使用信号量<code>Semaphore</code>之后：厕所坑位增加到5个（自己指定），这样可以5个人一起上厕所了==&gt; 实现了一定程度的并发控制</p>
<p>先看下缩略的源码：（可以这么想：<strong>内部维护了一个引用计数，每次来个任务就-1，一个任务结束计数就+1</strong>）</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Semaphore</span><span class="p">(</span><span class="n">_ContextManagerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Semaphore initial value must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">loop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

    <span class="n">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fut</span><span class="p">)</span> <span class="c1"># 把当前任务放入Queue中</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">await</span> <span class="n">fut</span> <span class="c1"># 等待一个任务的完成再继续</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">fut</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1"># 任务取消</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fut</span><span class="o">.</span><span class="n">cancelled</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wake_up_next</span><span class="p">()</span> <span class="c1"># 唤醒下一个任务</span>
                <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># 用掉一个并发量</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 恢复一个并发量</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wake_up_next</span><span class="p">()</span> <span class="c1"># 唤醒下一个任务</span>
</pre></div>
<p>现在举个常见的场景：<strong>比如调用某个免费的api，该api限制并发数为5</strong></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">sem</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># 模拟api请求</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">api_test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">sem</span><span class="p">:</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;The Task {i} is done&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">sem</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 设置并发数为5</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">api_test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>动态输出：
<img src="../../../images/python/2018-12-07/11.sem.gif" alt="2018-12-07/11.sem.gif"></p>
<p><strong>PS：<code>BoundedSemaphore</code>是<code>Semaphore</code>的一个版本，在调用<code>release()</code>时检查计数器的值是否超过了计数器的初始值，如果超过了就抛出一个异常</strong></p>
<h4 id="5.Event&#65288;&#20107;&#20214;&#65289;">5.Event&#65288;&#20107;&#20214;&#65289;<a class="anchor-link" href="#5.Event&#65288;&#20107;&#20214;&#65289;">&#182;</a></h4><p>线程篇<code>Event</code>：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.8.线程同步~Event">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.8.线程同步~Event</a></p>
<p>之前讲的很详细了，举个<code>爬虫批量更新</code>的例子就一笔带过：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">event</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">html_dict</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">updates</span><span class="p">():</span>
    <span class="c1"># event.wait()是协程方法，需要await</span>
    <span class="n">await</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="c1"># 入库操作省略 html_dict &gt;&gt; DB</span>
    <span class="k">return</span> <span class="s2">&quot;html_dict &gt;&gt; DB done&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 摸拟网络请求</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">html_dict</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;&lt;h1&gt;{url}&lt;/h1&gt;&quot;</span> <span class="c1"># 可以暂时写入临时文件中</span>

    <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>  <span class="c1"># 标记完成，普通方法</span>
    <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;{url} done&quot;</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">event</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>  <span class="c1"># 初始化 event 对象</span>

    <span class="c1"># 创建批量任务</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">get_html</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;www.mmd.com/a/{i}&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># 批量更新操作</span>
    <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">updates</span><span class="p">()))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>['www.mmd.com/a/1 done', 'www.mmd.com/a/2 done', 'www.mmd.com/a/3 done', 'www.mmd.com/a/4 done', 'www.mmd.com/a/5 done', 'www.mmd.com/a/6 done', 'www.mmd.com/a/7 done', 'www.mmd.com/a/8 done', 'www.mmd.com/a/9 done', 'html_dict &gt;&gt; DB done']
2.0012683868408203</code></pre>
<p>跟之前基本上一样，就一个地方不太一样：<code>async def wait(self)</code>，<code>wait</code>方法现在是协程方法了，使用的时候需要<code>await</code></p>
<ol>
<li><strong><code>coroutine wait()</code></strong><ul>
<li>等待事件内部标志被设置为<code>True</code></li>
<li>如果事件的内部内部标志已设置，则立即返回<code>True</code>。否则，一直阻塞，直到另外的任务调用<code>set()</code></li>
</ul>
</li>
<li><strong><code>set()</code></strong><ul>
<li>设置事件内部标志为<code>True</code></li>
<li>所有等待事件的任务将会立即被触发</li>
</ul>
</li>
<li><strong><code>clear()</code></strong><ul>
<li>清除事件内部标志（即重置为<code>False</code>）</li>
<li>等待事件的任务将会阻塞，直到<code>set()</code>方法被再次调用</li>
</ul>
</li>
<li><strong><code>is_set()</code></strong><ul>
<li>如果事件内部标志被设置为<code>True</code>，则返回<code>True</code></li>
</ul>
</li>
</ol>
<h4 id="6.Condition&#65288;&#26465;&#20214;&#21464;&#37327;&#65289;">6.Condition&#65288;&#26465;&#20214;&#21464;&#37327;&#65289;<a class="anchor-link" href="#6.Condition&#65288;&#26465;&#20214;&#21464;&#37327;&#65289;">&#182;</a></h4><p>线程篇<code>Condition</code>：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.4.线程同步~条件变量Condition">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.4.线程同步~条件变量Condition</a></p>
<p>先简单看看方法列表：</p>
<ol>
<li><strong><code>coroutine acquire()</code></strong>：<ul>
<li>获取底层锁。该方法一直等待，直到底层锁处于未锁定状态，然后设置其为锁定状态，并且返回True</li>
</ul>
</li>
<li><code>notify(n=1)</code>：<ul>
<li>唤醒至多n个等待条件的任务。如果没有正在等待的任务，则该方法无操作。</li>
<li>在调用该方法之前，必须先调用<code>acquire()</code>获取锁，并在调用该方法之后释放锁。</li>
<li>如果在锁为锁定的情况下调用此方法，会引发<code>RuntimeError</code>异常。</li>
</ul>
</li>
<li><code>locked()</code>：<ul>
<li>如果底层锁已获取，则返回True。</li>
</ul>
</li>
<li><code>notify_all()</code>：<ul>
<li>唤醒所有正在等待该条件的任务。该方法与notify()类似，区别只在它会唤醒所有正在等待的任务。</li>
</ul>
</li>
<li><code>release()</code>：<ul>
<li>释放底层锁。在未锁定的锁上调用时，会引发RuntimeError异常。</li>
</ul>
</li>
<li><strong><code>coroutine wait()</code></strong>：<ul>
<li>等待通知。如果调用此方法的任务没有获取到锁，则引发RuntimeError异常。</li>
<li>此方法释放底层锁，然后保持阻塞，直至被notify()或notify_all()唤醒。被唤醒之后，条件对象重新申请锁，该方法返回True。</li>
</ul>
</li>
<li><strong><code>coroutine wait_for(predicate)</code></strong><ul>
<li>等待<code>predicate</code>变为True。<code>predicate</code>必须可调用，它的执行结果会被解释为布尔值，并作为最终结果返回。</li>
</ul>
</li>
</ol>
<p>PS：<strong><code>Condition</code>结合了<code>Event</code>和<code>Lock</code>的功能</strong>(也可以使多个Condition对象共享一个Lock，允许不同任务之间协调对共享资源的独占访问)</p>
<p>看个生产消费者的案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">cond</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">p_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 生产者</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">async</span> <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">p_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{n}-{i}&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[生产者{n}]生产商品{n}-{i}&quot;</span><span class="p">)</span>
            <span class="c1"># 通知任意一个消费者</span>
            <span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>  <span class="c1"># 通知全部消费者：cond.notify_all()</span>
        <span class="c1"># 摸拟一个耗时操作</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># 消费者</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">async</span> <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p_list</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;列表商品：{p_list}&quot;</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">p_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># 消费商品</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[消费者{i}]消费商品{name}&quot;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;列表剩余：{p_list}&quot;</span><span class="p">)</span>

                <span class="c1"># 摸拟一个耗时操作</span>
                <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">await</span> <span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">cond</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>  <span class="c1"># 初始化condition</span>
    <span class="n">p_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">producer</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>  <span class="c1"># 两个生产者</span>
    <span class="n">c_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">consumer</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># 五个消费者</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">p_tasks</span><span class="p">,</span> <span class="o">*</span><span class="n">c_tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
<p>输出：</p>

<pre><code>[生产者0]生产商品0-0
[生产者1]生产商品1-0
列表商品：['0-0', '1-0']
[消费者0]消费商品1-0
列表剩余：['0-0']
列表商品：['0-0']
[消费者1]消费商品0-0
列表剩余：[]
[生产者0]生产商品0-1
[生产者1]生产商品1-1
列表商品：['0-1', '1-1']
[消费者0]消费商品1-1
列表剩余：['0-1']
列表商品：['0-1']
[消费者1]消费商品0-1
列表剩余：[]
[生产者0]生产商品0-2
[生产者1]生产商品1-2
列表商品：['0-2', '1-2']
[消费者0]消费商品1-2
列表剩余：['0-2']
列表商品：['0-2']
[消费者1]消费商品0-2
列表剩余：[]
[生产者0]生产商品0-3
[生产者1]生产商品1-3
列表商品：['0-3', '1-3']
[消费者0]消费商品1-3
列表剩余：['0-3']
列表商品：['0-3']
[消费者1]消费商品0-3
列表剩余：[]
[生产者0]生产商品0-4
[生产者1]生产商品1-4
列表商品：['0-4', '1-4']
[消费者0]消费商品1-4
列表剩余：['0-4']
列表商品：['0-4']
[消费者1]消费商品0-4
列表剩余：[]</code></pre>
<p>PS：第七条的简单说明：（来看看<code>wait_for</code>方法的源码）</p>
<div class="highlight"><pre><span></span><span class="c1"># 一直等到函数返回true（从返回结果来说：要么一直阻塞，要么返回true）</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">predicate</span><span class="p">()</span>
    <span class="c1"># 如果不是返回true就继续等待</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">predicate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<p>课后拓展：<code>async_timeout</code>（兼容async的超时的上下文管理器）
<a href="https://github.com/lotapp/BaseCode/blob/master/python/5.concurrent/ZCoroutine/async_timeout_timeout.py">https://github.com/lotapp/BaseCode/blob/master/python/5.concurrent/ZCoroutine/async_timeout_timeout.py</a></p>
<h4 id="7.Queue&#65288;&#38431;&#21015;&#65289;">7.Queue&#65288;&#38431;&#21015;&#65289;<a class="anchor-link" href="#7.Queue&#65288;&#38431;&#21015;&#65289;">&#182;</a></h4><p>官方文档：<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a></p>
<p>线程篇<code>Queue</code>：<a href="https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.6.线程同步~Queue-引入">https://www.cnblogs.com/dotnetcrazy/p/9528315.html#2.2.6.线程同步~Queue-引入</a></p>
<p>其实你不考虑限流的情况下，协程里面的queue和list基本上差不多（ps：<code>asyncio.Queue(num)</code>可以指定数量）</p>
<p>举个经典的生产消费者案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[生产者{i}]商品{num}出厂了&quot;</span><span class="p">)</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;[消费者{i}]商品{data}抢光了&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># 为了演示，我这边限制一下</span>

    <span class="n">p_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">producer</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>  <span class="c1"># 两个生产者</span>
    <span class="n">c_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">consumer</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># 五个消费者</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">p_tasks</span><span class="p">,</span> <span class="o">*</span><span class="n">c_tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（注意一下<code>get</code>和<code>put</code>方法都是协程方法即可）</p>

<pre><code>[生产者0]商品0.20252203397767787出厂了
[生产者0]商品0.9641503458079388出厂了
[消费者0]商品0.20252203397767787抢光了
[消费者0]商品0.9641503458079388抢光了
[生产者1]商品0.8049655468032324出厂了
[消费者0]商品0.8049655468032324抢光了
[生产者1]商品0.6032743557097342出厂了
[消费者1]商品0.6032743557097342抢光了
[生产者2]商品0.08818326334746773出厂了
[消费者2]商品0.08818326334746773抢光了
[生产者3]商品0.3747289313977561出厂了
[消费者3]商品0.3747289313977561抢光了
[生产者4]商品0.3948823110071299出厂了
[消费者4]商品0.3948823110071299抢光了
[生产者2]商品0.5775767044660681出厂了
[消费者0]商品0.5775767044660681抢光了
[生产者3]商品0.500537752889471出厂了
[消费者1]商品0.500537752889471抢光了
[生产者4]商品0.9921528527523727出厂了
[消费者2]商品0.9921528527523727抢光了</code></pre>
<p>PS：协程也提供了<strong><code>Priority Queue</code>优先级队列 and <code>LifoQueue</code>后进先出队列</strong>，这边就不再啰嗦了(前面我们<strong>画图演示并手动实现过</strong>)</p>
<p>课后拓展：<a href="https://docs.python.org/3/library/asyncio-queue.html#examples">https://docs.python.org/3/library/asyncio-queue.html#examples</a></p>
<h3 id="&#25193;&#23637;&#65306;Subprocesses">&#25193;&#23637;&#65306;Subprocesses<a class="anchor-link" href="#&#25193;&#23637;&#65306;Subprocesses">&#182;</a></h3><p>官方文档：<a href="https://docs.python.org/3/library/asyncio-subprocess.html">https://docs.python.org/3/library/asyncio-subprocess.html</a></p>
<p>这个之前进程篇的时候说过，不是我们今天的重点，我贴一个官方demo：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span>
        <span class="n">cmd</span><span class="p">,</span>
        <span class="n">stdout</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="n">stderr</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>

    <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">await</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;[{cmd!r} exited with {proc.returncode}]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stdout</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;[stdout]</span><span class="se">\n</span><span class="s1">{stdout.decode()}&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stderr</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;[stderr]</span><span class="se">\n</span><span class="s1">{stderr.decode()}&#39;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /zzz&#39;</span><span class="p">))</span>
</pre></div>
<p>输出：</p>

<pre><code>['ls /zzz' exited with 1]
[stderr]
ls: /zzz: No such file or directory</code></pre>
<p>下节预告：<strong><code>asyncio</code>+<code>aiohttp</code>版爬虫</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="4.aiohttp">4.aiohttp<a class="anchor-link" href="#4.aiohttp">&#182;</a></h2><p>代码：<a href="https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine/z_spider">https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/ZCoroutine/z_spider</a></p>
<p><code>asyncio</code>库只有<code>TCP</code>和<code>UDP</code>服务，并不支持<code>HTTP</code>，<code>aiohttp</code>就可以理解为是基于<code>asyncio</code>的<code>http</code>服务</p>
<h3 id="4.1.&#20837;&#38376;&#26696;&#20363;">4.1.&#20837;&#38376;&#26696;&#20363;<a class="anchor-link" href="#4.1.&#20837;&#38376;&#26696;&#20363;">&#182;</a></h3><p>先来个获取页面html的demo：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>

<span class="n">error_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># 获取页面html</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">await</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>  <span class="c1"># 添加到待处理集合中</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;http://www.biquge.cm/12/12097/&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>  <span class="c1"># 获取到html</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>24287
0.5429983139038086</code></pre>
<h3 id="4.2.html&#35299;&#26512;">4.2.html&#35299;&#26512;<a class="anchor-link" href="#4.2.html&#35299;&#26512;">&#182;</a></h3><p>推荐一款轻量级网页解析库：<strong><code>pyquery</code></strong>（一个类似jquery的python库）</p>
<h4 id="4.2.1.&#21015;&#34920;&#39029;">4.2.1.&#21015;&#34920;&#39029;<a class="anchor-link" href="#4.2.1.&#21015;&#34920;&#39029;">&#182;</a></h4><p>在上面基础上简单提取：（<code>pq.items("dd a")</code> ==&gt; 类比JQ选择器）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">from</span> <span class="nn">pyquery</span> <span class="kn">import</span> <span class="n">PyQuery</span>

<span class="n">error_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># 获取页面html</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">await</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>  <span class="c1"># 待处理的url集合</span>

<span class="c1"># 阻塞方法</span>
<span class="k">def</span> <span class="nf">saves</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;www.biquge.cm.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;a+&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;http://www.biquge.cm/12/12097/&quot;</span><span class="p">)</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="n">PyQuery</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span><span class="o">.</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s2">&quot;href&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">pq</span><span class="o">.</span><span class="n">items</span><span class="p">(</span><span class="s2">&quot;dd a&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># print(pq(&quot;dd a&quot;).text())</span>

        <span class="c1"># 兼容阻塞旧代码</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">saves</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：<code>www.biquge.cm.txt</code></p>

<pre><code>新书的一些话:/12/12097/7563947.html
第一章论坛里的鬼故事。:/12/12097/7563949.html
第二章临时讲课:/12/12097/7563950.html
第三章鬼域。:/12/12097/7563951.html
第四章恐怖敲门鬼:/12/12097/7565568.html
第五章迷路:/12/12097/7565569.html
第六章厕所中的手:/12/12097/7565570.html
第七章身后的脚步:/12/12097/7565571.html
第八章奇怪的树:/12/12097/7565572.html
第九章鬼婴:/12/12097/7565573.html
第十章恶鬼之力:/12/12097/7565574.html
...
第三百二十七章三口箱子:/12/12097/7950281.html
第三百二十八章鬼橱里的照片:/12/12097/7952145.html
第三百二十九章中山市事件:/12/12097/7955244.html
第三百三十章两条信息:/12/12097/7956401.html
第三百三十一章进入中山市:/12/12097/7959077.html
第三百三十二章出乎意料:/12/12097/7962119.html
第三百三十四章酒店的二楼:/12/12097/7964192.html
第三百三十五章黑色的烛火:/12/12097/7969058.html
第三百三十六章微笑的尸体:/12/12097/7973826.html</code></pre>
<h4 id="4.2.2.&#35814;&#24773;&#39029;">4.2.2.&#35814;&#24773;&#39029;<a class="anchor-link" href="#4.2.2.&#35814;&#24773;&#39029;">&#182;</a></h4><p>获取一个详情页看看：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">from</span> <span class="nn">pyquery</span> <span class="kn">import</span> <span class="n">PyQuery</span>

<span class="n">error_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># 获取页面html</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">await</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>  <span class="c1"># 待处理的url集合</span>

<span class="c1"># 详情页获取测试</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span>
                           <span class="s2">&quot;http://www.biquge.cm//12/12097/7563949.html&quot;</span><span class="p">)</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="n">PyQuery</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">pq</span><span class="p">(</span><span class="s2">&quot;#content&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">())</span>
        <span class="c1"># results = [item.text() for item in pq.items(&quot;#content&quot;)]</span>
        <span class="c1"># print(results)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>老夫掐指一算，你现在正在床上看小说，而且还是侧身，搞不好手机还在充电。

正在读高三的杨间此刻正躺在被窝里无聊的翻看着手机，他随手点开了一个帖子，下面有不少网友在回帖。

“卧槽，楼主真乃神人也，这都被楼主猜中了。”

“呵，你会告诉你们我现在正在厕所蹲坑么？不用问了，脚麻了。”

......

0.6684205532073975</code></pre>
<p><strong>PS：Win下Py包安装出错就去这个网站下对应包</strong> <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<h3 id="4.3.&#29228;&#34411;&#23567;&#26696;&#20363;">4.3.&#29228;&#34411;&#23567;&#26696;&#20363;<a class="anchor-link" href="#4.3.&#29228;&#34411;&#23567;&#26696;&#20363;">&#182;</a></h3><h4 id="4.3.1.&#23567;&#35828;&#32593;&#31449;&#23454;&#25112;">4.3.1.&#23567;&#35828;&#32593;&#31449;&#23454;&#25112;<a class="anchor-link" href="#4.3.1.&#23567;&#35828;&#32593;&#31449;&#23454;&#25112;">&#182;</a></h4><p>限流以及反爬虫和如何应对反爬虫机制，后面我们会继续说，这边简单举个小说离线的例子：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">from</span> <span class="nn">pyquery</span> <span class="kn">import</span> <span class="n">PyQuery</span>

<span class="n">sem</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">error_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># 获取html</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">sem</span><span class="p">:</span>
        <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
                <span class="c1"># aiohttp遇到非法字符的处理</span>
                <span class="k">return</span> <span class="n">await</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;gbk&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">)</span>  <span class="c1"># 忽略非法字符</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>  <span class="c1"># 待处理的url集合</span>

<span class="c1"># 获取文章正文</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">get_text</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="c1"># 把相对路径改成域名+路径</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;http://www.biquge.cm&quot;</span><span class="p">):</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.biquge.cm&quot;</span> <span class="o">+</span> <span class="n">url</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PyQuery</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pq</span><span class="p">(</span><span class="s2">&quot;#content&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>

<span class="c1"># 普通阻塞方法</span>
<span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;恐怖复苏.md&quot;</span><span class="p">,</span> <span class="s2">&quot;a+&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;gbk&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;## {title}</span><span class="se">\n\n</span><span class="s2">{text}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{title} done...&quot;</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">sem</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 控制并发数反而更快</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">await</span> <span class="n">fetch</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;http://www.biquge.cm/12/12097/&quot;</span><span class="p">)</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="n">PyQuery</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">pq</span><span class="o">.</span><span class="n">items</span><span class="p">(</span><span class="s2">&quot;dd a&quot;</span><span class="p">):</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">await</span> <span class="n">get_text</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s2">&quot;href&quot;</span><span class="p">))</span>
            <span class="c1"># 兼容阻塞旧代码</span>
            <span class="n">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;task over&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
<p>输出：（爬取整站就不用我说了吧：<code>提取a标签中的src，url去重后爬取内容</code>）</p>

<pre><code>新书的一些话 done...
第一章论坛里的鬼故事。 done...
第二章临时讲课 done...
第三章鬼域。 done...
第四章恐怖敲门鬼 done...
第五章迷路 done...
第六章厕所中的手 done...
第七章身后的脚步 done...
第八章奇怪的树 done...
第九章鬼婴 done...
第十章恶鬼之力 done...
第十一章逐渐复苏 done...
第十二章宛如智障 done...
第十三章羊皮纸 done...
第十四章诡异的纸 done...
......
第三百二十八章鬼橱里的照片 done...
第三百二十九章中山市事件 done...
第三百三十章两条信息 done...
第三百三十一章进入中山市 done...
第三百三十二章出乎意料 done...
第三百三十四章酒店的二楼 done...
第三百三十五章黑色的烛火 done...
第三百三十六章微笑的尸体 done...
task over</code></pre>
<p>动态展示：
<img src="../../../images/python/2018-12-07/动态展示.gif" alt="动态展示.gif"></p>
<h3 id="&#38386;&#35328;&#30862;&#35821;">&#38386;&#35328;&#30862;&#35821;<a class="anchor-link" href="#&#38386;&#35328;&#30862;&#35821;">&#182;</a></h3><p><strong>【推荐】Python高性能异步框架</strong>：<a href="https://github.com/LessChina/sanic">https://github.com/LessChina/sanic</a></p>
<p>逆天点评：（只看主线，只说我的见识）</p>
<ol>
<li>原来大家都是使用大一统的<code>Django</code>（方便）</li>
<li>后来因为性能不佳，FaceBook开发了<code>Tornado</code>（IO多路复用）来代替</li>
<li>再后来时代主流是敏捷开发，于是就有了<code>Flask</code>（简单）</li>
<li>后来Node和Go火了，NetCore也出山了，Python的Flask等同步框架总是被吊打</li>
<li>于是被逼出了<code>Japronto</code>，瞬间惊艳和吊打的所有开发语言，但是只是冒了泡就不怎么维护了</li>
<li>后来就是AI爆发时期，Python直接打上了AI的标签了，而Web也逐渐被打上了初创公司的标配</li>
<li>之后官方看不下去了，自己搞了一套异步框架<code>asyncio</code>and<code>aiohttp</code>（Node兄弟这么优秀，凭啥我们不行）</li>
<li>民间看不下去了来了个<code>asyncio</code>替代品<strong><code>uvloop</code></strong>（C实现的程度比官方多(谁多谁高效)，PS：官方用法太丑陋了3.7才给足了语法糖）</li>
<li>解决方案虽然各种出，但是web框架不行啊，于是又冒了个主流<strong><code>sanic</code></strong>（语法和<code>Flask</code>很像，性能不亚于<code>Japronto</code>）</li>
<li>现在又刚冒出<strong><code>vibora</code></strong>（都是C实现）有超过<code>sanic</code>的趋势（PS：等过几个版本再试水，不过现在很多开发者都是<code>Go + Python</code>了)</li>
</ol>
<p>最后BB一句：</p>
<ol>
<li><code>gevent</code>用猴子补丁的确很方便，但很多内部异常就被屏蔽了，而且性能现在不是最高</li>
<li><code>tornado</code>为了兼容<code>py2</code>和<code>py3</code>，内部还是通过生成器来实现异步的，效率相对低点</li>
<li><code>asyncio</code>是未来的主流方向，<code>sanic</code>是目前最火的异步框架（<code>vibora</code>还在观察中）</li>
</ol>
<p>PS：<code>Django</code>、<code>Flask</code>是阻塞式IO，web框架一般不会直接部署（它自带的解决方案只是方便调试），一般使用<code>uwsgi</code> or <code>gunicorn</code> + <code>nginx</code>来部署（tornado可以直接部署）</p>
<p>参考链接：</p>

<pre><code>python异步编程之asyncio
https://www.cnblogs.com/shenh/p/9090586.html

uWSGI, Gunicorn, 啥玩意儿?
https://www.cnblogs.com/gdkl/p/6807667.html

asyncio异步IO中文翻译：
http://www.cnblogs.com/mamingqian/p/10008279.html
https://www.cnblogs.com/mamingqian/p/10075444.html
https://www.cnblogs.com/mamingqian/p/10044730.html

PyQuery基础：
https://www.cnblogs.com/zhaof/p/6935473.html
https://www.cnblogs.com/lei0213/p/7676254.html</code></pre>

</div>
</div>
</div>
    </div>
  </div>
</body>

 


</html>
