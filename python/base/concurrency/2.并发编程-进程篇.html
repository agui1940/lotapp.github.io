<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<title>2.并发编程-进程篇</title>
<script src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" href="../../../style/css/jupyter.all.min.css">
<script src="../../../style/js/mynav.min.js" async></script>
</head>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>上次说了很多Linux下进程相关知识，这边不再复述，下面来说说Python的并发编程，如有错误欢迎提出～</p>
<p>如果遇到听不懂的可以看上一次的文章：<a href="https://www.cnblogs.com/dotnetcrazy/p/9363810.html" target="_blank">https://www.cnblogs.com/dotnetcrazy/p/9363810.html</a></p>
<p>官方文档：<a href="https://docs.python.org/3/library/concurrency.html" target="_blank">https://docs.python.org/3/library/concurrency.html</a></p>
<h2 id="1.&#36827;&#31243;&#31687;">1.&#36827;&#31243;&#31687;<a class="anchor-link" href="#1.&#36827;&#31243;&#31687;">&#182;</a></h2><p>官方文档：<a href="https://docs.python.org/3/library/multiprocessing.html" target="_blank">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p>Code：<a href="https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/PythonProcess" target="_blank">https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/PythonProcess</a></p>
<h3 id="1.1.&#36827;&#31243;&#65288;Process&#65289;">1.1.&#36827;&#31243;&#65288;Process&#65289;<a class="anchor-link" href="#1.1.&#36827;&#31243;&#65288;Process&#65289;">&#182;</a></h3><p>Python的进程创建非常方便，看个案例：(这种方法通用，fork只适用于Linux系)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="c1"># 注意一下，导入的是Process不是process（Class是大写开头）</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程-</span><span class="si">%s</span><span class="s2">]PID：</span><span class="si">%d</span><span class="s2">，PPID：</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PID：</span><span class="si">%d</span><span class="s2">，PPID：</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;萌萌哒&quot;</span><span class="p">,</span> <span class="p">))</span> <span class="c1"># 单个元素的元组表达别忘了(x,)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># 父进程回收子进程资源（内部调用了wait系列方法）</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>运行结果：</p>

<pre><code>[父进程]PID：25729，PPID：23434
[子进程-萌萌哒]PID：25730，PPID：25729</code></pre>
<p>创建子进程时，传入一个执行函数和参数，用start()方法来启动进程即可</p>
<p><code>join()</code>方法是父进程回收子进程的封装（主要是回收<a href="https://www.cnblogs.com/dotnetcrazy/p/9363810.html#2.2.僵尸进程和孤儿进程" target="_blank">僵尸子进程(点我)</a>）</p>
<p>其他参数可以参考源码 or 文档，贴一下源码的<code>init</code>方法：</p>
<p><code>def __init__(self,group=None,target=None,name=None,args=(),kwargs={},*,daemon=None)</code></p>
<p>扩展：<code>name：为当前进程实例的别名</code></p>
<ol>
<li><code>p.is_alive()</code> 判断进程实例p是否还在执行</li>
<li><code>p.terminate()</code> 终止进程（发<code>SIGTERM</code>信号）</li>
</ol>
<p>上面的案例如果用OOP来实现就是这样：(如果不指定方法，默认调Run方法)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="k">class</span> <span class="nc">My_Process</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
    <span class="c1"># 重写了Proce类的Init方法</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">Process</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># 调用父类方法</span>

    <span class="c1"># 重写了Process类的run()方法</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程-</span><span class="si">%s</span><span class="s2">]PID：</span><span class="si">%d</span><span class="s2">，PPID：</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                          <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PID：</span><span class="si">%d</span><span class="s2">，PPID：</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">My_Process</span><span class="p">(</span><span class="s2">&quot;萌萌哒&quot;</span><span class="p">)</span> <span class="c1"># 如果不指定方法，默认调Run方法</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># 父进程回收子进程资源（内部调用了wait系列方法）</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>PS：<code>multiprocessing.Process</code>自行处理僵死进程，不用像<code>os.fork</code>那样自己建立信号处理程序、安装信号处理程序</p>
<hr>
<h3 id="1.1.&#28304;&#30721;&#25299;&#23637;">1.1.&#28304;&#30721;&#25299;&#23637;<a class="anchor-link" href="#1.1.&#28304;&#30721;&#25299;&#23637;">&#182;</a></h3><p>现在说说里面的一些门道（只想用的可以忽略）</p>
<p>新版本的封装可能多层，这时候可以看看Python3.3.X系列（这个算是Python3早期版本了，很多代码都暴露出来，比较明了直观）</p>
<p>multiprocessing.process.py</p>
<div class="highlight"><pre><span></span><span class="c1"># 3.4.x开始，Process有了一个BaseProcess</span>
<span class="c1"># https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/process.py</span>
<span class="c1"># https://github.com/lotapp/cpython3/tree/master/Lib/multiprocessing/process.py</span>
<span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;一直等到子进程over&#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
    <span class="c1"># 断言（False就触发异常，提示就是后面的内容</span>
    <span class="c1"># 开发中用的比较多，部署的时候可以python3 -O xxx 去除所以断言</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="s2">&quot;只能 join 一个子进程&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_popen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;只能加入一个已启动的进程&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_popen</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="c1"># 本质就是用了我们之前讲的wait系列</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># 销毁子进程</span>
</pre></div>
<p>multiprocessing.popen_fork.py</p>
<div class="highlight"><pre><span></span><span class="c1"># 3.4.x开始，在popen_fork文件中（以前是multiprocessing.forking.py）</span>
<span class="c1"># https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/popen_fork.py</span>
<span class="c1"># https://github.com/lotapp/cpython3/tree/master/Lib/multiprocessing/popen_fork.py</span>
<span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># 设置超时的一系列处理</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">wait</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">],</span> <span class="n">timeout</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="c1"># 核心操作</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span> <span class="k">if</span> <span class="n">timeout</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span>

<span class="c1"># 回顾一下上次说的：os.WNOHANG - 如果没有子进程退出，则不阻塞waitpid()调用</span>
<span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 他的内部调用了waitpid</span>
            <span class="n">pid</span><span class="p">,</span> <span class="n">sts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># 子进程尚未创建</span>
            <span class="c1"># e.errno == errno.ECHILD == 10</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">WIFSIGNALED</span><span class="p">(</span><span class="n">sts</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">=</span> <span class="o">-</span><span class="n">os</span><span class="o">.</span><span class="n">WTERMSIG</span><span class="p">(</span><span class="n">sts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">sts</span><span class="p">),</span> <span class="s2">&quot;Status is {:n}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">sts</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span>
</pre></div>
<p>关于断言的简单说明：（别泛滥）</p>
<p>如果条件为真，它什么都不做，反之它触发一个带可选错误信息的AssertionError</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;哥哥，分母不能为0啊&quot;</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>结果：</p>

<pre><code>Traceback (most recent call last):
  File "0.assert.py", line 11, in &lt;module&gt;
    main()
  File "0.assert.py", line 7, in main
    test(1, 0)
  File "0.assert.py", line 2, in test
    assert b != 0, "哥哥，分母不能为0啊"
AssertionError: 哥哥，分母不能为0啊</code></pre>
<p>运行的时候可以指定<code>-O参数</code>来忽略<code>assert</code>，eg：</p>
<p><code>python3 -O 0.assert.py</code></p>

<pre><code>Traceback (most recent call last):
  File "0.assert.py", line 11, in &lt;module&gt;
    main()
  File "0.assert.py", line 7, in main
    test(1, 0)
  File "0.assert.py", line 3, in test
    return a / b
ZeroDivisionError: division by zero</code></pre>
<hr>
<p>扩展：</p>
<p><a href="https://docs.python.org/3/library/unittest.html" target="_blank">https://docs.python.org/3/library/unittest.html</a></p>
<p><a href="https://www.cnblogs.com/shangren/p/8038935.html" target="_blank">https://www.cnblogs.com/shangren/p/8038935.html</a></p>
<hr>
<h3 id="1.2.&#36827;&#31243;&#27744;">1.2.&#36827;&#31243;&#27744;<a class="anchor-link" href="#1.2.&#36827;&#31243;&#27744;">&#182;</a></h3><p>多个进程就不需要自己手动去管理了，有Pool来帮你完成，先看个案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>  <span class="c1"># 首字母大写</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程-</span><span class="si">%s</span><span class="s2">]PID=</span><span class="si">%d</span><span class="s2">，PPID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PID=</span><span class="si">%d</span><span class="s2">，PPID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># 设置最多5个进程（不设置就默认为CPU核数）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># 异步执行</span>
        <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">))</span> <span class="c1"># 同步用apply（如非必要不建议用）</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> <span class="c1"># 关闭池，不再加入新任务</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># 等待所有子进程执行完毕回收资源（join可以指定超时时间，eg：`p.join(1)`）</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;over&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>图示：（join可以指定超时时间，eg：<code>p.join(1)</code>）
<img src="../../../images/python/2018-08-03/1.进程池.gif" alt="1.进程池"></p>
<p><strong>调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了</strong>(<a href="#pool.join源码分析" target="_blank">下面会说为什么</a>)</p>
<hr>
<h3 id="1.3.&#28304;&#30721;&#25299;&#23637;">1.3.&#28304;&#30721;&#25299;&#23637;<a class="anchor-link" href="#1.3.&#28304;&#30721;&#25299;&#23637;">&#182;</a></h3><p>验证一下<strong>Pool的默认大小是CPU的核数</strong>，看源码：</p>
<p>multiprocessing.pool.py</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/pool.py</span>
<span class="c1"># https://github.com/lotapp/cpython3/tree/master/Lib/multiprocessing/pool.py</span>
<span class="k">class</span> <span class="nc">Pool</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="o">=</span><span class="err">指定的进程数</span><span class="p">,</span><span class="o">...</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">processes</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">1</span> <span class="c1"># os.cpu_count() ~ CPU的核数</span>
</pre></div>
<p>源码里面<code>apply_async</code>方法，是有回调函数（callback）的</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(),</span><span class="n">kwds</span><span class="o">=</span><span class="p">{},</span><span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">error_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">RUN</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pool not running&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ApplyResult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">error_callback</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_taskqueue</span><span class="o">.</span><span class="n">put</span><span class="p">(([(</span><span class="n">result</span><span class="o">.</span><span class="n">_job</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)],</span> <span class="bp">None</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<p>来看个例子：(和JQ很像)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>  <span class="c1"># 首字母大写</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程</span><span class="si">%s</span><span class="s2">]PID=</span><span class="si">%d</span><span class="s2">，PPID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span>

<span class="k">def</span> <span class="nf">error_test</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程</span><span class="si">%s</span><span class="s2">]PID=</span><span class="si">%d</span><span class="s2">，PPID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;[子进程</span><span class="si">%s</span><span class="s2">]啊，我挂了～&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;成功之后的回调函数&quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程</span><span class="si">%s</span><span class="s2">]执行完毕&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>  <span class="c1"># 没有返回值就为None</span>

<span class="k">def</span> <span class="nf">error_callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;错误之后的回调函数&quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PID=</span><span class="si">%d</span><span class="s2">，PPID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>  <span class="c1"># CPU默认核数</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="c1"># 搞2个出错的看看</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span>
                <span class="n">error_test</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">),</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>  <span class="c1"># 异步执行</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 异步执行，成功后执行callback函数（有点像jq）</span>
            <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭池，不再加入新任务</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># 等待所有子进程执行完毕回收资源</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;over&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>[父进程]PID=12348，PPID=10999
[子进程0]PID=12349，PPID=12348
[子进程2]PID=12351，PPID=12348
[子进程1]PID=12350，PPID=12348
[子进程3]PID=12352，PPID=12348
[子进程4]PID=12352，PPID=12348
[子进程3]啊，我挂了～
[子进程4]啊，我挂了～
[子进程0]执行完毕
[子进程2]执行完毕
[子进程1]执行完毕
over</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>接着上面继续拓展，补充说说获取函数返回值。<code>上面是通过成功后的回调函数来获取返回值</code>，这次说说自带的方法：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">TimeoutError</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;开平方&quot;&quot;&quot;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">TimeoutError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;超时了～&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>apply_async</code>返回一个<code>ApplyResult</code>类，里面有个get方法可以获取返回值）</p>

<pre><code>&lt;multiprocessing.pool.ApplyResult object at 0x7fbc354f50b8&gt;
超时了～</code></pre>
<p>再举个例子，顺便把<code>Pool</code>里面的<code>map</code>和<code>imap</code>方法搞个案例（类比jq）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">obj_list</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">obj_list</span><span class="p">)</span>
        <span class="c1"># 返回一个可迭代类的实例对象</span>
        <span class="n">obj_iter</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">obj_iter</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">obj_iter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obj_iter</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
</pre></div>
<p>输出：</p>

<pre><code>100
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;multiprocessing.pool.IMapIterator object at 0x7ff7f9734198&gt;
1 4 9 16 25 36 49 64 81</code></pre>
<p>微微看一眼源码：(基础忘了可以查看==&gt; <a href="https://www.cnblogs.com/dotnetcrazy/p/9278573.html" target="_blank">点我</a> )</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IMapIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_job</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">job_counter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsorted</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cache</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_job</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="c1"># 返回一个迭代器</span>

    <span class="c1"># 实现next方法</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span> <span class="kn">from</span> <span class="bp">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">StopIteration</span> <span class="kn">from</span> <span class="bp">None</span>
                    <span class="k">raise</span> <span class="n">TimeoutError</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="n">success</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">raise</span> <span class="n">value</span>
<span class="o">......</span>
</pre></div>
<p>扩展：优雅杀死子进程的探讨 <a href="https://segmentfault.com/q/1010000005077517" target="_blank">https://segmentfault.com/q/1010000005077517</a></p>
<hr>
<h3 id="1.4.&#25299;&#23637;&#20043;subprocess">1.4.&#25299;&#23637;&#20043;subprocess<a class="anchor-link" href="#1.4.&#25299;&#23637;&#20043;subprocess">&#182;</a></h3><p>官方文档：<a href="https://docs.python.org/3/library/subprocess.html" target="_blank">https://docs.python.org/3/library/subprocess.html</a></p>
<p>还记得之前李代桃僵的<code>execlxxx</code>系列吗？</p>
<p>这不，<code>subprocess</code>就是它的一层封装，当然了要强大的多，先看个例子：（以<code>os.execlp</code>的例子为引）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># os.execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;)  # 执行Path环境变量可以搜索到的命令</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="s2">&quot;-al&quot;</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出</p>

<pre><code>总用量 44
drwxrwxr-x 2 dnt dnt 4096 8月   7 17:32 .
drwxrwxr-x 4 dnt dnt 4096 8月   6 08:01 ..
-rw-rw-r-- 1 dnt dnt  151 8月   3 10:49 0.assert.py
-rw-rw-r-- 1 dnt dnt  723 8月   5 18:00 1.process2.py
-rw-rw-r-- 1 dnt dnt  501 8月   3 10:20 1.process.py
-rw-rw-r-- 1 dnt dnt 1286 8月   6 08:16 2.pool1.py
-rw-rw-r-- 1 dnt dnt  340 8月   7 16:38 2.pool2.py
-rw-rw-r-- 1 dnt dnt  481 8月   7 16:50 2.pool3.py
-rw-rw-r-- 1 dnt dnt  652 8月   5 17:01 2.pool.py
-rw-rw-r-- 1 dnt dnt  191 8月   7 17:33 3.subprocess.py
CompletedProcess(args=['ls', '-al'], returncode=0)</code></pre>
<h4 id="&#25991;&#26723;">&#25991;&#26723;<a class="anchor-link" href="#&#25991;&#26723;">&#182;</a></h4><p>现在看下官方的文档描述来理解一下：</p>
<div class="highlight"><pre><span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">具有可访问I / O流的子进程</span>
<span class="sd">Subprocesses with accessible I/O streams</span>

<span class="sd">此模块允许您生成进程，连接到它们输入/输出/错误管道，并获取其返回代码。</span>
<span class="sd">This module allows you to spawn processes, connect to their</span>
<span class="sd">input/output/error pipes, and obtain their return codes.</span>

<span class="sd">完整文档可以查看：https://docs.python.org/3/library/subprocess.html</span>
<span class="sd">For a complete description of this module see the Python documentation.</span>

<span class="sd">Main API</span>
<span class="sd">========</span>
<span class="sd">run(...): 运行命令，等待它完成，然后返回`CompletedProcess`实例。</span>
<span class="sd">Runs a command, waits for it to complete, </span>
<span class="sd">then returns a CompletedProcess instance.</span>

<span class="sd">Popen(...): 用于在新进程中灵活执行命令的类</span>
<span class="sd">A class for flexibly executing a command in a new process</span>

<span class="sd">Constants（常量）</span>
<span class="sd">---------</span>
<span class="sd">DEVNULL: 特殊值，表示应该使用`os.devnull`</span>
<span class="sd">Special value that indicates that os.devnull should be used</span>

<span class="sd">PIPE:    表示应创建`PIPE`管道的特殊值</span>
<span class="sd">Special value that indicates a pipe should be created</span>

<span class="sd">STDOUT:  特殊值，表示`stderr`应该转到`stdout`</span>
<span class="sd">Special value that indicates that stderr should go to stdout</span>

<span class="sd">Older API（尽量不用，说不定以后就淘汰了）</span>
<span class="sd">=========</span>
<span class="sd">call(...): 运行命令，等待它完成，然后返回返回码。</span>
<span class="sd">Runs a command, waits for it to complete, then returns the return code.</span>

<span class="sd">check_call(...): Same as call() but raises CalledProcessError()</span>
<span class="sd">    if return code is not 0（返回值不是0就引发异常）</span>

<span class="sd">check_output(...): 与check_call（）相同,但返回`stdout`的内容,而不是返回代码</span>
<span class="sd">Same as check_call but returns the contents of stdout instead of a return code</span>

<span class="sd">getoutput(...): 在shell中运行命令，等待它完成，然后返回输出</span>
<span class="sd">Runs a command in the shell, waits for it to complete,then returns the output</span>

<span class="sd">getstatusoutput(...): 在shell中运行命令，等待它完成，然后返回一个（exitcode，output）元组</span>
<span class="sd">Runs a command in the shell, waits for it to complete,</span>
<span class="sd">then returns a (exitcode, output) tuple</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
<p>其实看看源码很有意思：（内部其实就是调用的<code>os.popen</code>【进程先导篇讲进程守护的时候用过】）</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="o">*</span><span class="n">popenargs</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">capture_output</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;stdin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;stdin和输入参数可能都不会被使用。&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stdin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PIPE</span>

    <span class="k">if</span> <span class="n">capture_output</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;stdout&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;stderr&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;不能和capture_outpu一起使用stdout 或 stderr&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stdout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PIPE</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stderr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PIPE</span>

    <span class="k">with</span> <span class="n">Popen</span><span class="p">(</span><span class="o">*</span><span class="n">popenargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">process</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TimeoutExpired</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">TimeoutExpired</span><span class="p">(</span>
                <span class="n">process</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>  <span class="c1"># 包括KeyboardInterrupt的通信处理。</span>
            <span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="c1"># 不用使用process.wait（），.__ exit__为我们做了这件事。</span>
            <span class="k">raise</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">retcode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CalledProcessError</span><span class="p">(</span>
                <span class="n">retcode</span><span class="p">,</span> <span class="n">process</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">stderr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompletedProcess</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">retcode</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">)</span>
</pre></div>
<p>返回值类型：<code>CompletedProcess</code></p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/subprocess.py</span>
<span class="k">class</span> <span class="nc">CompletedProcess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">returncode</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">=</span> <span class="n">returncode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">stdout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">stderr</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;对象按指定的格式显示&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;args={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span>
            <span class="s1">&#39;returncode={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stdout={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdout</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stderr={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;{}({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">check_returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;如果退出代码非零，则引发CalledProcessError&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CalledProcessError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>
<h4 id="&#31616;&#21333;demo">&#31616;&#21333;demo<a class="anchor-link" href="#&#31616;&#21333;demo">&#182;</a></h4><p>再来个案例体会一下方便之处：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;ping&quot;</span><span class="p">,</span> <span class="s2">&quot;www.baidu.com&quot;</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>图示：
<img src="../../../images/python/2018-08-03/2.subprocess.gif" alt="2.subprocess.gif"></p>
<h4 id="&#20132;&#20114;demo">&#20132;&#20114;demo<a class="anchor-link" href="#&#20132;&#20114;demo">&#182;</a></h4><p>再来个强大的案例（交互的程序都可以，比如 <strong><code>ftp</code>，<code>nslookup</code></strong> 等等）：<code>popen1.communicate</code></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;ipython3&quot;</span><span class="p">],</span>
        <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 对pstree进行交互</span>
        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;print(&quot;hello&quot;)&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Out:</span><span class="si">%s</span><span class="se">\n</span><span class="s2">Err:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="n">err</span><span class="o">.</span><span class="n">decode</span><span class="p">()))</span>
    <span class="k">except</span> <span class="n">TimeoutError</span><span class="p">:</span>
        <span class="c1"># 如果超时到期，则子进程不会被终止，需要自己处理一下</span>
        <span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Out:</span><span class="si">%s</span><span class="se">\n</span><span class="s2">Err:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="n">err</span><span class="o">.</span><span class="n">decode</span><span class="p">()))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: hello

In [2]: Do you really want to exit ([y]/n)?

Err:</code></pre>
<p>注意点：如果超时到期，则子进程不会被终止，需要自己处理一下（官方提醒）</p>
<h4 id="&#36890;&#20449;demo">&#36890;&#20449;demo<a class="anchor-link" href="#&#36890;&#20449;demo">&#182;</a></h4><p>这个等会说进程间通信还会说，所以简单举个例子，老规矩拿<code>ps aux | grep bash</code>说事：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># ps aux | grep bash</span>
    <span class="c1"># 进程1获取结果</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s2">&quot;ps&quot;</span><span class="p">,</span> <span class="s2">&quot;-aux&quot;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="c1"># 得到进程1的结果再进行筛选</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s2">&quot;grep&quot;</span><span class="p">,</span> <span class="s2">&quot;bash&quot;</span><span class="p">],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="c1"># 关闭写段（结果已经获取到进程2中了，防止干扰显示）</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># 与流程交互：将数据发送到stdin并关闭它。</span>
    <span class="n">msg_tuple</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
    <span class="c1"># 输出结果</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（以前案例：<a href="https://www.cnblogs.com/dotnetcrazy/p/9363810.html#2.4.3.进程间通信～PIPE匿名管道（常用）" target="_blank">进程间通信～PIPE匿名管道</a>）</p>

<pre><code>dnt       2470  0.0  0.1  24612  5236 pts/0    Ss   06:01   0:00 bash
dnt       2512  0.0  0.1  24744  5760 pts/1    Ss   06:02   0:00 bash
dnt      20784  0.0  0.1  24692  5588 pts/2    Ss+  06:21   0:00 /bin/bash
dnt      22377  0.0  0.0  16180  1052 pts/1    S+   06:30   0:00 grep bash</code></pre>
<p>其他扩展可以看看这篇文章：<a href="http://www.cnblogs.com/Security-Darren/p/4733368.html" target="_blank">subprocess与Popen()</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;PIPE&#31649;&#36947;&#36890;&#20449;">1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;PIPE&#31649;&#36947;&#36890;&#20449;<a class="anchor-link" href="#1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;PIPE&#31649;&#36947;&#36890;&#20449;">&#182;</a></h3><p>这个比较有意思，看个案例：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="n">w</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;[子进程]老爸，老妈回来记得喊我一下～&quot;</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;[父进程]滚犊子，赶紧写作业，不然我得跪方便面！&quot;</span><span class="p">)</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>结果：</p>

<pre><code>老爸，老妈回来记得喊我一下～
滚犊子，赶紧写作业，不然我得跪方便面！</code></pre>
<h4 id="multiprocessing.Pipe&#28304;&#30721;&#20998;&#26512;">multiprocessing.Pipe&#28304;&#30721;&#20998;&#26512;<a class="anchor-link" href="#multiprocessing.Pipe&#28304;&#30721;&#20998;&#26512;">&#182;</a></h4><p>按照道理应该子进程自己写完自己读了，和上次讲得不一样啊？不急，先看看源码：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/context.py</span>
<span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duplex</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;返回由管道连接的两个连接对象&#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.connection</span> <span class="kn">import</span> <span class="n">Pipe</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="p">)</span>
</pre></div>
<p>看看<code>connection.Pipe</code>方法的定义部分，是不是双向通信就看你是否设置<code>duplex=True</code></p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/connection.py</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;返回管道两端的一对连接对象&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">duplex</span><span class="p">:</span>
            <span class="c1"># 双工内部其实是socket系列（下次讲）</span>
            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 这部分就是我们上次讲的pipe管道</span>
            <span class="n">fd1</span><span class="p">,</span> <span class="n">fd2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">readable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
<span class="k">else</span><span class="p">:</span> 
    <span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c1"># win平台的一系列处理</span>
        <span class="o">......</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">PipeConnection</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="n">duplex</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">PipeConnection</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">readable</span><span class="o">=</span><span class="n">duplex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
</pre></div>
<p>通过源码知道了，原来双工是通过socket搞的啊～</p>
<p>再看个和原来一样效果的案例：（不用关来关去的了，方便！）</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="c1"># 只能写</span>
    <span class="n">w</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;[子进程]老爸，咱们完了，老妈一直在门口～&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"># 你把这个放在join前面就直接死锁了</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span> <span class="c1"># 只能读</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（可以思考下为什么<code>start换个位置就死锁</code>，提示：<code>阻塞读写</code>）</p>

<pre><code>[子进程]老爸，咱们完了，老妈一直在门口～</code></pre>
<p>再举个<code>Pool</code>的例子，咱们就进入今天的重点了：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">proc_test1</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;[小明]小张，今天哥们要见一女孩，你陪我呗，我24h等你回复哦～&quot;</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">proc_test2</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;[小张]不去，万一被我帅气的外表迷倒就坑了～&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">conn1</span><span class="p">,</span> <span class="n">conn2</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">proc_test1</span><span class="p">,</span> <span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">proc_test2</span><span class="p">,</span> <span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭池，不再接收新任务</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># 等待回收，必须先关才能join，不然会异常</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="err">小明</span><span class="p">]</span><span class="err">小张，今天哥们要见一女孩，你陪我呗，我</span><span class="mi">24</span><span class="n">h等你回复哦</span><span class="err">～</span>
<span class="p">[</span><span class="err">小张</span><span class="p">]</span><span class="err">不去，万一被我帅气的外表迷倒就坑了～</span>
</pre></div>
<h4 id="pool.join&#28304;&#30721;&#20998;&#26512;">pool.join&#28304;&#30721;&#20998;&#26512;<a class="anchor-link" href="#pool.join&#28304;&#30721;&#20998;&#26512;">&#182;</a></h4><p>看看源码就理解了：<strong>看看Pool的join是啥情况？看源码：</strong></p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/pool.py</span>
<span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/pool.py</span>
<span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">util</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;joining pool&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">RUN</span><span class="p">:</span>
        <span class="c1"># 没关闭就join，这边就会抛出一个异常</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pool is still running&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">CLOSE</span><span class="p">,</span> <span class="n">TERMINATE</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In unknown state&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_worker_handler</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_task_handler</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># 循环join回收</span>
</pre></div>
<p>在pool的<code>__init__</code>的方法中，这几个属性：</p>
<div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">=</span> <span class="n">processes</span> <span class="c1"># 指定的进程数</span>
<span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 列表</span>
<span class="bp">self</span><span class="o">.</span><span class="n">_repopulate_pool</span><span class="p">()</span> <span class="c1"># 给列表append内容的方法</span>
</pre></div>
<p>将池进程的数量增加到指定的数量，join的时候会使用这个列表</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_repopulate_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># 指定进程数-当前进程数，差几个补几个</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">)):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span>
                         <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inqueue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outqueue</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_initializer</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_initargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxtasksperchild</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_exception</span><span class="p">)</span>
                        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="c1"># 重点来了</span>
        <span class="n">w</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Process&#39;</span><span class="p">,</span> <span class="s1">&#39;PoolWorker&#39;</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># pool退出后，通过pool创建的进程都会退出</span>
        <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">util</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;added worker&#39;</span><span class="p">)</span>
</pre></div>
<p>注意：<strong>池的方法只能由创建它的进程使用</strong></p>
<hr>
<h3 id="1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;Queue&#31649;&#36947;&#36890;&#20449;&#65288;&#24120;&#29992;&#65289;">1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;Queue&#31649;&#36947;&#36890;&#20449;&#65288;&#24120;&#29992;&#65289;<a class="anchor-link" href="#1.5.&#36827;&#31243;&#38388;&#36890;&#20449;&#65374;Queue&#31649;&#36947;&#36890;&#20449;&#65288;&#24120;&#29992;&#65289;">&#182;</a></h3><p>一步步的设局，从底层的的<code>pipe()</code>-&gt;<code>os.pipe</code>-&gt;<code>PIPE</code>，现在终于到<code>Queue</code>了，心酸啊，明知道上面两个项目</p>
<p>里面基本上不会用，但为了你们能看懂源码，说了这么久<code>%&gt;_&lt;%</code>其实以后当我们从<code>Queue</code>说到<code>MQ</code>和<code>RPC</code>之后，现在</p>
<p>讲得这些进程间通信(<code>IPC</code>)也基本上不会用了，但本质你得清楚，我尽量多分析点源码，这样你们以后看开源项目压力会很小</p>
<p>欢迎批评指正～</p>
<h4 id="&#24341;&#20837;&#26696;&#20363;">&#24341;&#20837;&#26696;&#20363;<a class="anchor-link" href="#&#24341;&#20837;&#26696;&#20363;">&#182;</a></h4><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程]老爸，我出去嗨了&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[父进程]去吧比卡丘～&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>get</code>和<code>put</code>默认是阻塞等待的）</p>

<pre><code>[子进程]老爸，我出去嗨了
[父进程]去吧比卡丘～</code></pre>
<h4 id="&#28304;&#30721;&#25299;&#23637;">&#28304;&#30721;&#25299;&#23637;<a class="anchor-link" href="#&#28304;&#30721;&#25299;&#23637;">&#182;</a></h4><p>先看看<code>Queue</code>的初始化方法：（不指定大小就是最大队列数）</p>
<div class="highlight"><pre><span></span><span class="c1"># 队列类型，使用PIPE，缓存，线程</span>
<span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ctx = multiprocessing.get_context(&quot;xxx&quot;)</span>
    <span class="c1"># 上下文总共3种：spawn、fork、forkserver（扩展部分会提一下）</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># 默认使用最大容量</span>
        <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.synchronize</span> <span class="kn">import</span> <span class="n">SEM_VALUE_MAX</span> <span class="k">as</span> <span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>  <span class="c1"># 指定队列大小</span>
        <span class="c1"># 创建了一个PIPE匿名管道（单向）</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c1"># `multiprocessing/synchronize.py &gt; Lock`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  <span class="c1"># 进程锁（读）【非递归】</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>  <span class="c1"># 获取PID</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wlock</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wlock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  <span class="c1"># 进程锁（写）【非递归】</span>
        <span class="c1"># Semaphore信号量通常用于保护容量有限的资源</span>
        <span class="c1"># 控制信号量,超了就异常</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>
        <span class="c1"># 不忽略PIPE管道破裂的错误</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_epipe</span> <span class="o">=</span> <span class="bp">False</span> 
        <span class="c1"># 线程相关操作</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_after_fork</span><span class="p">()</span>
        <span class="c1"># 向`_afterfork_registry`字典中注册</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
            <span class="n">register_after_fork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Queue</span><span class="o">.</span><span class="n">_after_fork</span><span class="p">)</span>
</pre></div>
<p>关于<code>get</code>和<code>put</code>是阻塞的问题，看下源码探探究竟：</p>
<p><code>q.get()</code>：收消息</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c1"># 默认情况是阻塞（lock加锁）</span>
    <span class="k">if</span> <span class="n">block</span> <span class="ow">and</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  <span class="c1"># 信号量+1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
            <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
        <span class="c1"># 超时抛异常</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Empty</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                <span class="c1"># 不管有没有内容都去读，超时就抛异常</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">Empty</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">Empty</span>
            <span class="c1"># 接收字节数据作为字节对象</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  <span class="c1"># 信号量+1</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># 释放锁</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="c1"># 释放锁后，重新序列化数据</span>
    <span class="k">return</span> <span class="n">_ForkingPickler</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></div>
<p><code>queue.put()</code>:发消息</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># 如果Queue已经关闭就抛异常</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">,</span> <span class="s2">&quot;Queue {0!r} has been closed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># 记录信号量的锁</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Full</span>  <span class="c1"># 超过数量，抛个异常</span>
        <span class="c1"># 条件变量允许一个或多个线程等待，直到另一个线程通知它们</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start_thread</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
</pre></div>
<p>非阻塞<code>get_nowait</code>和<code>put_nowait</code>本质其实也是调用了<code>get</code>和<code>put</code>方法：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
<h4 id="&#36827;&#31243;&#38388;&#36890;&#20449;1">&#36827;&#31243;&#38388;&#36890;&#20449;1<a class="anchor-link" href="#&#36827;&#31243;&#38388;&#36890;&#20449;1">&#182;</a></h4><p>说这么多不如来个例子看看：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 只能 put 3条消息</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  <span class="c1"># put一个List类型的消息</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>  <span class="c1"># put一个Dict类型的消息</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>  <span class="c1"># put一个Set类型的消息</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 不加timeout，就一直阻塞，等消息队列有空位才能发出去</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;再加条消息呗&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Full(Exception)是空实现，你可以直接用Exception</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;消息队列已满，队列数</span><span class="si">%s</span><span class="s2">，当前存在</span><span class="si">%s</span><span class="s2">条消息&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">()))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 非阻塞，不能put就抛异常</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="s2">&quot;再加条消息呗&quot;</span><span class="p">)</span>  <span class="c1"># 相当于q.put(obj,False)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;消息队列已满，队列数</span><span class="si">%s</span><span class="s2">，当前存在</span><span class="si">%s</span><span class="s2">条消息&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">()))</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;队列数：</span><span class="si">%s</span><span class="s2">，当前存在</span><span class="si">%s</span><span class="s2">条消息 内容</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">(),</span> <span class="n">q</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()))</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;队列数：</span><span class="si">%s</span><span class="s2">，当前存在：</span><span class="si">%s</span><span class="s2">条消息&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">()))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>消息队列已满，队列数3，当前存在3条消息
消息队列已满，队列数3，当前存在3条消息
队列数：3，当前存在3条消息 内容[1, 2, 3, 4]
队列数：3，当前存在2条消息 内容{'a': 1, 'b': 2}
队列数：3，当前存在1条消息 内容{1, 2, 3, 4}
队列数：3，当前存在：0条消息</code></pre>
<p>补充说明一下：</p>
<ol>
<li><em><code>q._maxsize</code></em> 队列数(尽量不用<code>_</code>开头的属性和方法）</li>
<li><code>q.qsize()</code>查看当前队列中存在几条消息</li>
<li><code>q.full()</code>查看是否满了</li>
<li><code>q.empty()</code>查看是否为空</li>
</ol>
<p>再看个简单点的子进程间通信：(铺垫demo)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">pro_test1</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程1]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程1]小明，今晚撸串不？&quot;</span><span class="p">)</span>

    <span class="c1"># 设置一个简版的重试机制（三次重试）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 第一次1s，第二次4s，第三次6s</span>

<span class="k">def</span> <span class="nf">pro_test2</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程2]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 模拟一下网络延迟</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程2]不去，我今天约了妹子&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">pro_test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">pro_test2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>time python3 5.queue2.py</code>）</p>

<pre><code>[子进程1]PPID=15220,PID=15221,GID=1000
[子进程2]PPID=15220,PID=15222,GID=1000
[子进程1]小明，今晚撸串不？
[子进程2]不去，我今天约了妹子

real    0m6.087s
user    0m0.053s
sys 0m0.035s</code></pre>
<hr>
<h4 id="&#36827;&#31243;&#38388;&#36890;&#20449;2">&#36827;&#31243;&#38388;&#36890;&#20449;2<a class="anchor-link" href="#&#36827;&#31243;&#38388;&#36890;&#20449;2">&#182;</a></h4><p>多进程基本上都是用<code>pool</code>，可用上面说的<code>Queue</code>方法怎么报错了？</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">error_callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pro_test1</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程1]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程1]小明，今晚撸串不？&quot;</span><span class="p">)</span>

    <span class="c1"># 设置一个简版的重试机制（三次重试）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 第一次1s，第二次4s，第三次6s</span>

<span class="k">def</span> <span class="nf">pro_test2</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程2]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 模拟一下网络延迟</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程2]不去，我今天约了妹子&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                          <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：(无法将<code>multiprocessing.Queue</code>对象传递给<code>Pool</code>方法)</p>

<pre><code>[父进程]PPID=4223,PID=32170,GID=1000
Queue objects should only be shared between processes through inheritance
Queue objects should only be shared between processes through inheritance

real    0m0.183s
user    0m0.083s
sys 0m0.012s</code></pre>
<p>下面会详说，先看一下正确方式：（队列换了一下，其他都一样<code>Manager().Queue()</code>）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span> <span class="nf">error_callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pro_test1</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程1]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程1]小明，今晚撸串不？&quot;</span><span class="p">)</span>

    <span class="c1"># 设置一个简版的重试机制（三次重试）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 第一次1s，第二次4s，第三次6s</span>

<span class="k">def</span> <span class="nf">pro_test2</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程2]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 模拟一下网络延迟</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程2]不去，我今天约了妹子&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                          <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>[父进程]PPID=4223,PID=31329,GID=1000
[子进程1]PPID=31329,PID=31335,GID=1000
[子进程2]PPID=31329,PID=31336,GID=1000
[子进程1]小明，今晚撸串不？
[子进程2]不去，我今天约了妹子

real    0m6.134s
user    0m0.133s
sys 0m0.035s</code></pre>
<p>再抛个思考题：（Linux）</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">error_callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">pro_test1</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">q</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程1]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程1]小明，今晚撸串不？&quot;</span><span class="p">)</span>
    <span class="c1"># 设置一个简版的重试机制（三次重试）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 第一次1s，第二次4s，第三次6s</span>

<span class="k">def</span> <span class="nf">pro_test2</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">q</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程2]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                           <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 模拟一下网络延迟</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程2]不去，我今天约了妹子&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">,GID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                          <span class="n">os</span><span class="o">.</span><span class="n">getgid</span><span class="p">()))</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test1</span><span class="p">,</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test2</span><span class="p">,</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（为啥这样也可以【提示：<code>fork</code>】）</p>

<pre><code>[父进程]PPID=12855,PID=16879,GID=1000
[子进程1]PPID=16879,PID=16880,GID=1000
[子进程2]PPID=16879,PID=16881,GID=1000
[子进程1]小明，今晚撸串不？
[子进程2]不去，我今天约了妹子

real    0m6.120s
user    0m0.105s
sys     0m0.024s</code></pre>
<h3 id="&#36827;&#31243;&#25299;&#23637;">&#36827;&#31243;&#25299;&#23637;<a class="anchor-link" href="#&#36827;&#31243;&#25299;&#23637;">&#182;</a></h3><p>官方参考：<a href="https://docs.python.org/3/library/multiprocessing.html" target="_blank">https://docs.python.org/3/library/multiprocessing.html</a></p>
<h4 id="1.&#19978;&#19979;&#25991;&#31995;">1.&#19978;&#19979;&#25991;&#31995;<a class="anchor-link" href="#1.&#19978;&#19979;&#25991;&#31995;">&#182;</a></h4><ol>
<li>spawn：（Win默认，Linux下也可以用【&gt;=3.4】）<ol>
<li>父进程启动一个新的python解释器进程。</li>
<li>子进程只会继承运行进程对象run()方法所需的那些资源。</li>
<li>不会继承父进程中不必要的文件描述符和句柄。</li>
<li>与使用fork或forkserver相比，使用此方法启动进程相当慢。</li>
<li>可在Unix和Windows上使用。Windows上的默认设置。</li>
</ol>
</li>
<li>fork:（Linux下默认）<ol>
<li>父进程用于os.fork()分叉Python解释器。</li>
<li>子进程在开始时与父进程相同（这时候内部变量之类的还没有被修改）</li>
<li>父进程的所有资源都由子进程继承（用到多线程的时候可能有些问题）</li>
<li>仅适用于Unix。Unix上的默认值。</li>
</ol>
</li>
<li>forkserver：（常用）<ol>
<li>当程序启动并选择forkserver start方法时，将启动服务器进程。</li>
<li>从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。</li>
<li>fork服务器进程是单线程的，因此它可以安全使用os.fork()。没有不必要的资源被继承。</li>
<li>可在Unix平台上使用，支持通过Unix管道传递文件描述符。</li>
</ol>
</li>
</ol>
<p>这块官方文档很详细，贴下官方的2个案例：</p>
<p>通过<code>multiprocessing.set_start_method(xxx)</code>来设置启动的上下文类型</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">mp</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span> <span class="c1"># 不要过多使用</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>set_start_method</code>不要过多使用）</p>

<pre><code>hello

real    0m0.407s
user    0m0.134s
sys     0m0.012s</code></pre>
<p>如果你把设置启动上下文注释掉：（消耗的总时间少了很多）</p>

<pre><code>real    0m0.072s
user    0m0.057s
sys     0m0.016s</code></pre>
<p>也可以通过<code>multiprocessing.get_context(xxx)</code>获取指定类型的上下文</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>get_context</code>在Python源码里用的比较多，so=&gt;也建议大家这么用）</p>

<pre><code>hello

real    0m0.169s
user    0m0.146s
sys 0m0.024s</code></pre>
<p>从结果来看，总耗时也少了很多</p>
<hr>
<h4 id="2.&#26085;&#35760;&#31995;&#21015;">2.&#26085;&#35760;&#31995;&#21015;<a class="anchor-link" href="#2.&#26085;&#35760;&#31995;&#21015;">&#182;</a></h4><p>说下日记相关的事情：</p>
<p>先看下<code>multiprocessing</code>里面的日记记录：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/context.py</span>
<span class="k">def</span> <span class="nf">log_to_stderr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;打开日志记录并添加一个打印到stderr的处理程序&#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">log_to_stderr</span>
    <span class="k">return</span> <span class="n">log_to_stderr</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
</pre></div>
<p>更多<code>Loging</code>模块内容可以看官方文档：<a href="https://docs.python.org/3/library/logging.html" target="_blank">https://docs.python.org/3/library/logging.html</a></p>
<p>这个是内部代码，看看即可：</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/util.py</span>
<span class="k">def</span> <span class="nf">log_to_stderr</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;打开日志记录并添加一个打印到stderr的处理程序&#39;&#39;&#39;</span>
    <span class="c1"># 全局变量默认是False</span>
    <span class="k">global</span> <span class="n">_log_to_stderr</span>
    <span class="kn">import</span> <span class="nn">logging</span>

    <span class="c1"># 日记记录转换成文本</span>
    <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="n">DEFAULT_LOGGING_FORMAT</span><span class="p">)</span>
    <span class="c1"># 一个处理程序类，它将已适当格式化的日志记录写入流</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>  <span class="c1"># 此类不会关闭流，因为用到了sys.stdout|sys.stderr</span>
    <span class="c1"># 设置格式：&#39;[%(levelname)s/%(processName)s] %(message)s&#39;</span>
    <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>

    <span class="c1"># 返回`multiprocessing`专用的记录器</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">()</span>
    <span class="c1"># 添加处理程序</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">level</span><span class="p">:</span>
        <span class="c1"># 设置日记级别</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="c1"># 现在log是输出到stderr的</span>
    <span class="n">_log_to_stderr</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">_logger</span>
</pre></div>
<p><code>Logging</code>之前也有提过，可以看看：<a href="https://www.cnblogs.com/dotnetcrazy/p/9333792.html#2.装饰器传参的扩展（可传可不传）" target="_blank">https://www.cnblogs.com/dotnetcrazy/p/9333792.html#2.装饰器传参的扩展（可传可不传）</a></p>
<p>来个案例：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">log_to_stderr</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start_log</span><span class="p">():</span>
    <span class="c1"># 把日记输出定向到sys.stderr中</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">log_to_stderr</span><span class="p">()</span>
    <span class="c1"># 设置日记记录级别</span>
    <span class="c1"># 敏感程度：DEBUG、INFO、WARN、ERROR、CRITICAL</span>
    <span class="k">print</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARN</span> <span class="o">==</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>  <span class="c1"># 这两个是一样的</span>
    <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>  <span class="c1"># 设置日记级别(一般都是WARN)</span>

    <span class="c1"># 自定义输出</span>
    <span class="c1"># def log(self, level, msg, *args, **kwargs):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="s2">&quot;我是通用格式&quot;</span><span class="p">)</span>  <span class="c1"># 通用，下面的内部也是调用的这个</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;info 测试&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;warning 测试&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;error 测试&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">start_log</span><span class="p">()</span>
    <span class="c1"># 做的操作都会被记录下来</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>True
[INFO/MainProcess] 我是通用格式
[INFO/MainProcess] info 测试
[WARNING/MainProcess] warning 测试
[ERROR/MainProcess] error 测试
[INFO/Process-1] child process calling self.run()
test
[INFO/Process-1] process shutting down
[INFO/Process-1] process exiting with exitcode 0
[INFO/MainProcess] process shutting down</code></pre>
<hr>
<h4 id="3.&#36827;&#31243;5&#24577;">3.&#36827;&#31243;5&#24577;<a class="anchor-link" href="#3.&#36827;&#31243;5&#24577;">&#182;</a></h4><p>之前忘记说了～现在快结尾了，补充一下进程5态：(来个草图)</p>
<p><img src="../../../images/python/2018-08-03/3.进程5态.png" alt="3.进程5态.png"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="1.6.&#36827;&#31243;&#38388;&#29366;&#24577;&#20849;&#20139;">1.6.&#36827;&#31243;&#38388;&#29366;&#24577;&#20849;&#20139;<a class="anchor-link" href="#1.6.&#36827;&#31243;&#38388;&#29366;&#24577;&#20849;&#20139;">&#182;</a></h3><p>应该尽量避免进程间状态共享，但需求在那，所以还是得研究，官方推荐了两种方式：</p>
<h4 id="1.&#20849;&#20139;&#20869;&#23384;&#65288;Value-or-Array&#65289;">1.&#20849;&#20139;&#20869;&#23384;&#65288;<code>Value</code> or <code>Array</code>&#65289;<a class="anchor-link" href="#1.&#20849;&#20139;&#20869;&#23384;&#65288;Value-or-Array&#65289;">&#182;</a></h4><p>之前说过<code>Queue</code>：在<code>Process</code>之间使用没问题，用到<code>Pool</code>，就使用<code>Manager().xxx</code>，<code>Value</code>和<code>Array</code>，就不太一样了：</p>
<p>看看源码：（Manager里面的Array和Process共享的Array不是一个概念，而且也没有同步机制）</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/lotapp/cpython3/blob/master/Lib/multiprocessing/managers.py</span>
<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typecode</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_typecode</span> <span class="o">=</span> <span class="n">typecode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_typecode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="c1"># 给value设置get和set方法（和value的属性装饰器一样效果）</span>

<span class="k">def</span> <span class="nf">Array</span><span class="p">(</span><span class="n">typecode</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">typecode</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>
</pre></div>
<p>以<code>Process</code>为例看看怎么用：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Array</span>

<span class="k">def</span> <span class="nf">proc_test1</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;子进程1&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;子进程1&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">[:])</span>

<span class="k">def</span> <span class="nf">proc_test2</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;子进程2&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;子进程2&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">[:])</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">)</span>  <span class="c1"># d 类型，相当于C里面的double</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># i 类型，相当于C里面的int</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">proc_test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array</span><span class="p">))</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">proc_test2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array</span><span class="p">))</span>
        <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">p2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">p2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;父进程&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># 获取值</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;父进程&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">[:])</span>  <span class="c1"># 获取值</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;No Except&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（<code>Value</code>和<code>Array</code>是<code>进程|线程</code>安全的）</p>
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">multiprocessing</span><span class="o">.</span><span class="n">sharedctypes</span><span class="o">.</span><span class="n">Synchronized</span><span class="s1">&#39;&gt;</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">multiprocessing</span><span class="o">.</span><span class="n">sharedctypes</span><span class="o">.</span><span class="n">SynchronizedArray</span><span class="s1">&#39;&gt;</span>
<span class="err">子进程</span><span class="mi">1</span> <span class="mf">3.14</span>
<span class="err">子进程</span><span class="mi">1</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="err">子进程</span><span class="mi">2</span> <span class="mf">3.14</span>
<span class="err">子进程</span><span class="mi">2</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="err">父进程</span> <span class="mf">3.14</span>
<span class="err">父进程</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">No</span> <span class="n">Except</span>
</pre></div>
<p>类型方面的对应关系：</p>
<div class="highlight"><pre><span></span><span class="n">typecode_to_type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">,</span>
    <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_wchar</span><span class="p">,</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_byte</span><span class="p">,</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ubyte</span><span class="p">,</span>
    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_short</span><span class="p">,</span>
    <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ushort</span><span class="p">,</span>
    <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
    <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span>
    <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">,</span>
    <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulong</span><span class="p">,</span>
    <span class="s1">&#39;q&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">,</span>
    <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulonglong</span><span class="p">,</span>
    <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_float</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
<span class="p">}</span>
</pre></div>
<p>这两个类型其实是<code>ctypes</code>类型，更多的类型可以去<a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.sharedctypes" target="_blank">` multiprocessing.sharedctypes`</a>查看，来张图：
<img src="../../../images/python/2018-08-03/4.ctypes.png" alt="4.ctypes.png">
回头解决<code>GIL</code>的时候会用到<code>C</code>系列或者<code>Go</code>系列的共享库（讲线程的时候会说）</p>
<hr>
<p>关于进程安全的补充说明：对于原子性操作就不用说，铁定安全，但注意一下<code>i+=1</code>并不是原子性操作：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Value</span>

<span class="k">def</span> <span class="nf">proc_test1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">value</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">proc_test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
    <span class="c1"># 批量启动</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
        <span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c1"># 批量资源回收</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
        <span class="n">i</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（理论上应该是:5×1000=5000）</p>

<pre><code>2153</code></pre>
<p>稍微改一下才行：（<strong>进程安全：只是提供了安全的方法，并不是什么都不用你操心了</strong>）</p>
<div class="highlight"><pre><span></span><span class="c1"># 通用方法</span>
<span class="k">def</span> <span class="nf">proc_test1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">acquire</span><span class="p">():</span>
            <span class="n">value</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">value</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c1"># 官方案例：(Lock可以使用with托管)</span>
<span class="k">def</span> <span class="nf">proc_test1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">value</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
            <span class="n">value</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># 更多可以查看：`sharedctypes.SynchronizedBase` 源码</span>
</pre></div>
<p>输出：（关于锁这块，后面讲线程的时候会详说，看看就好【语法的确比C#麻烦点】）</p>

<pre><code>5000</code></pre>
<p>看看源码：（之前探讨如何优雅的杀死子进程，其中就有一种方法使用了<code>Value</code>）</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="n">typecode_or_type</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;返回Value的同步包装器&#39;&#39;&#39;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">RawValue</span><span class="p">(</span><span class="n">typecode_or_type</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="c1"># 默认支持Lock</span>
    <span class="k">if</span> <span class="n">lock</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span> <span class="ow">or</span> <span class="n">get_context</span><span class="p">()</span> <span class="c1"># 获取上下文</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span> <span class="c1"># 获取递归锁</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="s1">&#39;acquire&#39;</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> has no method &#39;acquire&#39;&quot;</span> <span class="o">%</span> <span class="n">lock</span><span class="p">)</span>
    <span class="c1"># 一系列处理</span>
    <span class="k">return</span> <span class="n">synchronized</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Array</span><span class="p">(</span><span class="n">typecode_or_type</span><span class="p">,</span> <span class="n">size_or_initializer</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;返回RawArray的同步包装器&#39;&#39;&#39;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">RawArray</span><span class="p">(</span><span class="n">typecode_or_type</span><span class="p">,</span> <span class="n">size_or_initializer</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="c1"># 默认是支持Lock的</span>
    <span class="k">if</span> <span class="n">lock</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span> <span class="ow">or</span> <span class="n">get_context</span><span class="p">()</span> <span class="c1"># 获取上下文</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>  <span class="c1"># 递归锁属性</span>
    <span class="c1"># 查看是否有acquire属性</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="s1">&#39;acquire&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> has no method &#39;acquire&#39;&quot;</span> <span class="o">%</span> <span class="n">lock</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">synchronized</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>
</pre></div>
<p>扩展部分可以查看这篇文章：<a href="http://blog.51cto.com/11026142/1874807" target="_blank">http://blog.51cto.com/11026142/1874807</a></p>
<hr>
<h4 id="2.&#26381;&#21153;&#22120;&#36827;&#31243;&#65288;Manager&#65289;">2.&#26381;&#21153;&#22120;&#36827;&#31243;&#65288;<code>Manager</code>&#65289;<a class="anchor-link" href="#2.&#26381;&#21153;&#22120;&#36827;&#31243;&#65288;Manager&#65289;">&#182;</a></h4><p>官方文档：<a href="https://docs.python.org/3/library/multiprocessing.html#managers" target="_blank">https://docs.python.org/3/library/multiprocessing.html#managers</a></p>
<p><strong>有一个服务器进程负责维护所有的对象，而其他进程连接到该进程，通过代理对象操作服务器进程当中的对象</strong></p>
<p>通过返回的经理<code>Manager()</code>将支持类型<code>list、dict、Namespace、Lock、RLock、Semaphore、BoundedSemaphore、Condition、Event、Barrier、Queue</code></p>
<p>举个简单例子（后面还会再说）：(本质其实就是<code>多个进程通过代理，共同操作服务端内容</code>)</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">d</span><span class="p">[</span><span class="mf">0.25</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">test2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="n">dict_test</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
        <span class="n">list_test</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dict_test</span><span class="p">,</span> <span class="n">list_test</span><span class="p">))</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dict_test</span><span class="p">,</span> <span class="n">list_test</span><span class="p">))</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：</p>

<pre><code>{1: '1', '2': 2, 0.25: None}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</code></pre>
<p>服务器进程管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。此外，单个管理器可以通过网络在不同计算机上的进程共享。但是，它们比使用共享内存慢（毕竟有了<code>“中介”</code>）</p>
<p>同步问题依然需要注意一下，举个例子体会一下：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>  <span class="c1"># 你可以把这句话注释掉，然后就知道为什么加了</span>
            <span class="n">dict1</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="n">dict1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">dict</span><span class="p">({</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">2000</span><span class="p">})</span>
        <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
            <span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
            <span class="n">i</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>扩展补充：</p>
<ol>
<li><code>multiprocessing.Lock</code>是一个进程安全对象，因此您可以将其直接传递给子进程并在所有进程中安全地使用它。</li>
<li>大多数可变Python对象（如list，dict,大多数类）不能保证进程中安全，所以它们在进程间共享时需要使用<code>Manager</code></li>
<li>多进程模式的缺点是创建进程的代价大，在<code>Unix/Linux</code>系统下，用<code>fork</code>调用还行，在<code>Windows</code>下创建进程开销巨大。</li>
</ol>
<p>Manager这块官方文档很详细，可以看看：<a href="https://docs.python.org/3/library/multiprocessing.html#managers" target="_blank">https://docs.python.org/3/library/multiprocessing.html#managers</a></p>
<p><code>WinServer</code>的可以参考<a href="https://www.cnblogs.com/bin-l/p/8615201.html" target="_blank">这篇</a> or <a href="https://blog.csdn.net/Solo95/article/details/78913709" target="_blank">这篇埋坑记</a>（Manager一般都是部署在Linux的，Win的客户端不影响）</p>
<h4 id="&#25193;&#23637;&#34917;&#20805;">&#25193;&#23637;&#34917;&#20805;<a class="anchor-link" href="#&#25193;&#23637;&#34917;&#20805;">&#182;</a></h4><p>还记得之前的：<a href="#进程间通信2"><strong>无法将multiprocessing.Queue对象传递给Pool方法</strong></a>吗？其实一般都是这两种方式解决的：</p>
<ol>
<li>使用Manager需要生成另一个进程来托管Manager服务器。 并且所有获取/释放锁的调用都必须通过IPC发送到该服务器。</li>
<li>使用初始化程序在池创建时传递常规<code>multiprocessing.Queue()</code>这将使<code>Queue</code>实例在所有子进程中全局共享</li>
</ol>
<p>再看一下Pool的<code>__init__</code>方法：</p>
<div class="highlight"><pre><span></span><span class="c1"># processes：进程数</span>
<span class="c1"># initializer,initargs 初始化进行的操作</span>
<span class="c1"># maxtaskperchild：每个进程执行task的最大数目</span>
<span class="c1"># contex：上下文对象</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">maxtasksperchild</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</pre></div>
<p>第一种方法不够轻量级，在讲案例前，稍微说下第二种方法：(也算把上面留下的悬念解了)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">error_callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pro_test1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程1]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程1]小明，今晚撸串不？&quot;</span><span class="p">)</span>

    <span class="c1"># 设置一个简版的重试机制（三次重试）</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 第一次1s，第二次4s，第三次6s</span>

<span class="k">def</span> <span class="nf">pro_test2</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[子进程2]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 模拟一下网络延迟</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[子进程2]不去，我今天约了妹子&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">q</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[父进程]PPID=</span><span class="si">%d</span><span class="s2">,PID=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">initializer</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test1</span><span class="p">,</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">pro_test2</span><span class="p">,</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">error_callback</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>输出：（就是在初始化Pool的时候，<strong>传了初始化执行的方法并传了参数</strong>：<code>alizer=init, initargs=(queue, ))</code>）</p>

<pre><code>[父进程]PPID=13157,PID=24864
[子进程1]PPID=24864,PID=24865
[子进程2]PPID=24864,PID=24866
[子进程1]小明，今晚撸串不？
[子进程2]不去，我今天约了妹子

real    0m6.105s
user    0m0.071s
sys     0m0.042s</code></pre>
<p>Win下亦通用（win下没有<code>os.getgid</code>）
<img src="../../../images/python/2018-08-03/5.win.png" alt="5.win.png"></p>
<hr>
<h3 id="1.7.&#20998;&#24067;&#24335;&#36827;&#31243;&#30340;&#26696;&#20363;">1.7.&#20998;&#24067;&#24335;&#36827;&#31243;&#30340;&#26696;&#20363;<a class="anchor-link" href="#1.7.&#20998;&#24067;&#24335;&#36827;&#31243;&#30340;&#26696;&#20363;">&#182;</a></h3><p>有了<code>1.6</code>的基础，咱们来个例子练练：</p>
<p><code>BaseManager</code>的缩略图：
<img src="../../../images/python/2018-08-03/6.缩略.png" alt="6.缩略.png"></p>
<p>服务器端代码：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 用来身份验证的</span>
    <span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92&quot;</span>
    <span class="n">get_zhang_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>  <span class="c1"># 小张消息队列</span>
    <span class="n">get_ming_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>  <span class="c1"># 小明消息队列</span>

    <span class="c1"># 把Queue注册到网络上, callable参数关联了Queue对象</span>
    <span class="n">BaseManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;get_zhang_queue&quot;</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">get_zhang_queue</span><span class="p">)</span>
    <span class="n">BaseManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;get_ming_queue&quot;</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">get_ming_queue</span><span class="p">)</span>

    <span class="c1"># 实例化一个Manager对象。绑定ip+端口, 设置验证秘钥</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;192.168.36.235&quot;</span><span class="p">,</span> <span class="mi">5438</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># 运行serve</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>客户端代码1：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;客户端1&quot;&quot;&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92&quot;</span>

    <span class="c1"># 注册对应方法的名字（从网络上获取Queue）</span>
    <span class="n">BaseManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;get_ming_queue&quot;</span><span class="p">)</span>
    <span class="n">BaseManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;get_zhang_queue&quot;</span><span class="p">)</span>

    <span class="c1"># 实例化一个Manager对象。绑定ip+端口, 设置验证秘钥</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;192.168.36.235&quot;</span><span class="p">,</span> <span class="mi">5438</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># 连接到服务器</span>
    <span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

    <span class="n">q1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_zhang_queue</span><span class="p">()</span>  <span class="c1"># 在自己队列里面留言</span>
    <span class="n">q1</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;[小张]小明，老大明天是不是去外地办事啊？&quot;</span><span class="p">)</span>

    <span class="n">q2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_ming_queue</span><span class="p">()</span>  <span class="c1"># 获取小明说的话</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q2</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>客户端代码2：</p>

<pre><code>from multiprocessing.managers import BaseManager

def main():
    """客户端2"""
    key = b"8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92"

    # 注册对应方法的名字（从网络上获取Queue）
    BaseManager.register("get_ming_queue")
    BaseManager.register("get_zhang_queue")

    # 实例化一个Manager对象。绑定ip+端口, 设置验证秘钥
    m = BaseManager(address=("192.168.36.235", 5438), authkey=key)
    # 连接到服务器
    m.connect()

    q1 = m.get_zhang_queue()  # 获取小张说的话
    print(q1.get())

    q2 = m.get_ming_queue()  # 在自己队列里面留言
    q2.put("[小明]这几天咱们终于可以不加班了(&gt;_&lt;)")

if __name__ == '__main__':
    main()</code></pre>
<p>输出图示：
<img src="../../../images/python/2018-08-03/7.manager.gif" alt="7.manager.gif">
服务器运行在Linux的测试：
<img src="../../../images/python/2018-08-03/8.win.png" alt="8.win.png"></p>
<p>其实还有一部分内容没说，明天得出去办点事，先到这吧，后面找机会继续带一下</p>
<hr>
<p>参考文章：</p>
<p>进程共享的探讨：<a href="https://stackoverflow.com/questions/25557686/python-sharing-a-lock-between-processes" target="_blank">python-sharing-a-lock-between-processes</a></p>
<p>多进程锁的探讨：<a href="https://stackoverflow.com/questions/17960296/trouble-using-a-lock-with-multiprocessing-pool-pickling-error" target="_blank">trouble-using-a-lock-with-multiprocessing-pool-pickling-error</a></p>
<p>JoinableQueue扩展：<a href="https://www.cnblogs.com/smallmars/p/7093603.html" target="_blank">https://www.cnblogs.com/smallmars/p/7093603.html</a></p>
<p>Python多进程编程：<a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank">https://www.cnblogs.com/kaituorensheng/p/4445418.html</a></p>
<p>有深度但需要辩证看的两篇文章：</p>
<p>跨进程对象共享：<a href="http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/" target="_blank">http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue</a></p>
<p>关于Queue：<a href="http://blog.ftofficer.com/2009/12/python-multiprocessing-2-object-sharing-across-process" target="_blank">http://blog.ftofficer.com/2009/12/python-multiprocessing-2-object-sharing-across-process</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="NetCore&#24182;&#21457;&#32534;&#31243;">NetCore&#24182;&#21457;&#32534;&#31243;<a class="anchor-link" href="#NetCore&#24182;&#21457;&#32534;&#31243;">&#182;</a></h2><p>示例代码：<a href="https://github.com/lotapp/BaseCode/tree/master/netcore/4_Concurrency" target="_blank">https://github.com/lotapp/BaseCode/tree/master/netcore/4_Concurrency</a></p>
<p>先简单说下概念（其实之前也有说，所以简说下）：</p>
<ol>
<li>并发：同时做多件事情</li>
<li>多线程：并发的一种形式</li>
<li>并行处理：多线程的一种（线程池产生的一种并发类型，eg：<strong>异步编程</strong>）</li>
<li>响应式编程：一种编程模式，对事件进行响应（有点类似于JQ的事件）</li>
</ol>
<p>Net里面很少用进程，在以前基本上都是<code>线程+池+异步+并行+协程</code></p>
<p>我这边简单引入一下，毕竟主要是写Python的教程，Net只是帮你们回顾一下，如果你发现还没听过这些概念，或者你的项目中还充斥着各种<code>Thread</code>和<code>ThreadPool</code>的话，真的得系统的学习一下了，现在官网的文档已经很完善了，记得早几年啥都没有，也只能挖那些外国开源项目：</p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-processing-and-concurrency" target="_blank">https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-processing-and-concurrency</a></p>
<h3 id="1.&#24322;&#27493;&#32534;&#31243;&#65288;Task&#65289;">1.&#24322;&#27493;&#32534;&#31243;&#65288;Task&#65289;<a class="anchor-link" href="#1.&#24322;&#27493;&#32534;&#31243;&#65288;Task&#65289;">&#182;</a></h3><p>Task的目的其实就是为了简化<code>Thread</code>和<code>ThreadPool</code>的代码，下面一起看看吧：</p>
<p>异步用起来比较简单，一般IO，DB，Net用的比较多，很多时候都会采用重试机制，举个简单的例子：</p>
<div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 模拟一个网络操作（别忘了重试机制）</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name=&quot;url&quot;&gt;url&lt;/param&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">async</span> <span class="k">static</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">DownloadStringAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// 设置第一次重试时间</span>
        <span class="kt">var</span> <span class="n">nextDelay</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">{</span> <span class="p">}</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">nextDelay</span><span class="p">);</span> <span class="c1">// 用异步阻塞的方式防止服务器被太多重试给阻塞了</span>
            <span class="n">nextDelay</span> <span class="p">*=</span> <span class="m">2</span><span class="p">;</span> <span class="c1">// 3次重试机会，第一次1s，第二次2s，第三次4s</span>
        <span class="p">}</span>
        <span class="c1">// 最后一次尝试，错误就抛出</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>然后补充说下Task异常的问题，当你await的时候如果有异常会抛出，在第一个await处捕获处理即可</p>
<p>如果<code>async</code>和<code>await</code>就是理解不了的可以这样想：<code>async</code>就是为了让<code>await</code>生效（为了向后兼容）</p>
<p>对了，如果返回的是void，你设置成Task就行了，触发是类似于事件之类的方法才使用void，不然没有返回值都是使用Task</p>
<p>项目里经常有这么一个场景：<strong>等待一组任务完成后再执行某个操作</strong>,看个引入案例：</p>
<div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 1.批量任务</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">async</span> <span class="k">static</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">[]&gt;</span> <span class="n">DownloadStringAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">url</span> <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>再举一个场景：<strong>同时调用多个同效果的API，有一个返回就好了，其他的忽略</strong></p>
<div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 2.返回首先完成的Task</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">GetIPAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">url</span> <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAny</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span> <span class="c1">// 返回第一个完成的Task</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>一个async方法被await调用后，当它恢复运行时就会回到原来的上下文中运行。</p>
<p>如果你的Task不再需要上下文了可以使用：<code>task.ConfigureAwait(false)</code>，eg：写个日记还要啥上下文？</p>
<p>逆天的建议是：<strong>在核心代码里面一种使用<code>ConfigureAwait</code>，用户页面相关代码，不需要上下文的加上</strong></p>
<p>其实如果有太多await在上下文里恢复那也是比较卡的，使用<code>ConfigureAwait</code>之后，被暂停后会在线程池里面继续运行</p>
<p>再看一个场景：比如一个耗时操作，我需要指定它的超时时间：</p>
<div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 3.超时取消</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">CancellMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//实例化取消任务</span>
    <span class="kt">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
    <span class="n">cts</span><span class="p">.</span><span class="n">CancelAfter</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">3</span><span class="p">));</span> <span class="c1">// 设置失效时间为3s</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nf">DoSomethingAsync</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 任务已经取消会引发TaskCanceledException</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">TaskCanceledException</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="k">return</span> <span class="s">&quot;false&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 模仿一个耗时操作</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">DoSomethingAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">),</span> <span class="n">token</span><span class="p">);</span>
    <span class="k">return</span> <span class="s">&quot;ok&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>异步这块简单回顾就不说了，留两个扩展，你们自行探讨：</p>
<ol>
<li>进度方面的可以使用<code>IProgress&lt;T&gt;</code>，就当留个作业自己摸索下吧～</li>
<li>使用了异步之后尽量避免使用<code>task.Wait</code> or <code>task.Result</code>，这样可以避免死锁</li>
</ol>
<p>Task其他新特征去官网看看吧，引入到此为止了。</p>
<hr>
<h3 id="2.&#24182;&#34892;&#32534;&#31243;&#65288;Parallel&#65289;">2.&#24182;&#34892;&#32534;&#31243;&#65288;Parallel&#65289;<a class="anchor-link" href="#2.&#24182;&#34892;&#32534;&#31243;&#65288;Parallel&#65289;">&#182;</a></h3><p>这个其实出来很久了，现在基本上都是用<code>PLinq</code>比较多点，主要就是：</p>
<ol>
<li><strong>数据并行</strong>：重点在处理数据（eg：聚合）</li>
<li><strong>任务并行</strong>：重点在执行任务（每个任务块尽可能独立，越独立效率越高）</li>
</ol>
<h4 id="&#25968;&#25454;&#24182;&#34892;">&#25968;&#25454;&#24182;&#34892;<a class="anchor-link" href="#&#25968;&#25454;&#24182;&#34892;">&#182;</a></h4><p>以前都是<code>Parallel.ForEach</code>这么用，现在和Linq结合之后非常方便<code>.AsParallel()</code>就OK了</p>
<p>说很抽象看个简单案例：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span> <span class="p">};</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">ParallelMethod</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 举个例子</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">ParallelMethod</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">AsParallel</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>正常执行的结果应该是：</p>

<pre><code>1
4
9
25
64
16
49
81</code></pre>
<p>并行之后就是这样了（不管顺序了）：</p>

<pre><code>25
64
1
9
49
81
4
16</code></pre>
<p>当然了，如果你就是对顺序有要求可以使用：<strong><code>.AsOrdered()</code></strong></p>
<div class="highlight"><pre><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 举个例子</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">private</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">ParallelMethod</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">AsParallel</span><span class="p">().</span><span class="n">AsOrdered</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>其实实际项目中，使用并行的时候：<strong>任务时间适中，太长不适合，太短也不适合</strong></p>
<p>记得大家在项目里经常会用到如<code>Sum</code>，<code>Count</code>等聚合函数，其实这时候使用并行就很合适</p>
<div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">list</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">GetSumParallel</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">static</span> <span class="kt">long</span> <span class="nf">GetSumParallel</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">AsParallel</span><span class="p">().</span><span class="n">Sum</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>time dotnet PLINQ.dll</p>

<pre><code>499999500000

real    0m0.096s
user    0m0.081s
sys 0m0.025s</code></pre>
<p>不使用并行：（稍微多了点，CPU越密集差距越大）</p>

<pre><code>499999500000

real    0m0.103s
user    0m0.092s
sys 0m0.021s</code></pre>
<p>其实聚合有一个通用方法，可以支持复杂的聚合：(以上面sum为例)</p>

<pre><code>.Aggregate(
            seed:0,
            func:(sum,item)=&gt;sum+item
          );</code></pre>
<p>稍微扩展一下，PLinq也是支持取消的，<strong><code>.WithCancellation(CancellationToken)</code></strong></p>
<p>Token的用法和上面一样，就不复述了，如果需要和异步结合，一个<code>Task.Run</code>就可以把并行任务交给线程池了</p>
<p>也可以使用Task的异步方法，设置超时时间，这样PLinq超时了也就终止了</p>
<p>PLinq这么方便，其实也是有一些小弊端的，比如它会直接最大程度的占用系统资源，可能会影响其他的任务，而传统的Parallel则会动态调整</p>
<hr>
<h4 id="&#20219;&#21153;&#24182;&#34892;&#65288;&#24182;&#34892;&#35843;&#29992;&#65289;">&#20219;&#21153;&#24182;&#34892;&#65288;&#24182;&#34892;&#35843;&#29992;&#65289;<a class="anchor-link" href="#&#20219;&#21153;&#24182;&#34892;&#65288;&#24182;&#34892;&#35843;&#29992;&#65289;">&#182;</a></h4><p>这个PLinq好像没有对应的方法，有新语法你可以说下，来举个例子：</p>
<div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="n">Parallel</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span>
        <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">3</span><span class="p">)),</span>
        <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">2</span><span class="p">))</span>
    <span class="p">));</span>
</pre></div>
<p>取消也支持：</p>
<div class="highlight"><pre><span></span><span class="n">Parallel</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="k">new</span> <span class="n">ParallelOptions</span><span class="p">()</span> <span class="p">{</span> <span class="n">CancellationToken</span> <span class="p">=</span> <span class="n">token</span> <span class="p">},</span> <span class="n">actions</span><span class="p">);</span>
</pre></div>
<h3 id="&#25193;&#20805;&#35828;&#26126;">&#25193;&#20805;&#35828;&#26126;<a class="anchor-link" href="#&#25193;&#20805;&#35828;&#26126;">&#182;</a></h3><p>其实还有一些比如<strong>数据流</strong>和<strong>响应编程</strong>没说，这个之前都是用第三方库，刚才看官网文档，好像已经支持了，所以就不卖弄了，感兴趣的可以去看看，其实项目里面有流数据相关的框架，eg：<code>Spark</code>，都是比较成熟的解决方案了基本上也不太使用这些了。</p>
<p>然后还有一些没说，比如NetCore里面<strong>不可变类型</strong>（列表、字典、集合、队列、栈、线程安全字典等等）以及<strong>限流</strong>、<strong>任务调度</strong>等，这些关键词我提一下，也方便你去搜索自己学习拓展</p>
<p>先到这吧，其他的自己探索一下吧，最后贴一些Nuget库，你可以针对性的使用：</p>
<ol>
<li><strong>数据流</strong>：<code>Microsoft.Tpl.Dataflow</code></li>
<li><strong>响应编程</strong>(Linq的Rx操作)：<code>Rx-Main</code></li>
<li><strong>不可变类型</strong>：<code>Microsoft.Bcl.Immutable</code></li>
</ol>
<p>不得不感慨一句，微软妈妈真的花了很多功夫，Net的并发编程比Python省心多了（完）</p>

</div>
</div>
</div>
    </div>
  </div>
</body>

 


</html>
